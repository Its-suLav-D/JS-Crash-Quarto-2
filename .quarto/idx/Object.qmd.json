{"title":"Objects","markdown":{"headingText":"Objects","containsRefs":false,"markdown":"\nObjects are core data structure in javascript. Particularly, it is an unorded collection of key-value pairs. You can use objects to store data, ogranize code, and represent real-world entities. It is crucial to retain that Object are reference values\n\nIn javascript, values can be either primite values or reference values: \n\nReference values, are complex data types that represent a reference to a value, rather than the value itself. The referenve values in JavaScript are: \n\n    - Objects (arrays, function, and classes)\n    - Maps \n    - Sets \n    - WeakMaps \n    - WeakSets \n\nHere is an example of an object in JavaScript:\n\n```{.js}\nlet object = {\n  key1: 'value1',\n  key2: 'value2',\n  key3: 'value3'\n};\n\n\n```\n\nIn this example, the object has three properties: key1, key2, and key3. Each property has a corresponding value, which can be a primitive data type (such as a string or number), or a more complex data type (such as an array or another object).\n\nYou can access the properties of an object using dot notation or bracket notation, like this:\n\n```{.js}\nconsole.log(object.key1); // Output: 'value1'\nconsole.log(object['key2']); // Output: 'value2'\n\n```\nYou can also add, remove, or modify the properties of an object using dot notation or bracket notation, like this:\n\n```{.js}\nobject.key4 = 'value4';\ndelete object.key3;\nobject['key2'] = 'new value';\n\n```\nObjects are often used to store data in the form of key-value pairs. For example, you might use an object to represent a person, like this:\n\n```{.js}\nlet person = {\n  name: 'John',\n  age: 10,\n  occupation: 'developer'\n};\n\n```\nYou can also use objects to store functions, which are known as methods. For example:\n\n```{.js}\nlet calculator = {\n  add: function(x, y) {\n    return x + y;\n  },\n  subtract: function(x, y) {\n    return x - y;\n  }\n};\n\nconsole.log(calculator.add(1, 2)); // Output: 3\nconsole.log(calculator.subtract(5, 3)); // Output: 2\n\n```\n\n> Objects are fundamental part of javascript and are used extensively in modern JavaScript Programming.\n\n\n## Object Spread Operator \n\nThe spread operator (...) in JavaScript can be used with objects to create a new object that combines the properties of the original object with additional properties or values. This is often referred to as object spreading or object rest/spread syntax.\n\nHere is an example of how to use the spread operator with an object:\n\n```{.js}\nlet object1 = {\n  key1: 'value1',\n  key2: 'value2'\n};\n\nlet object2 = {\n  key3: 'value3',\n  ...object1\n};\n\nconsole.log(object2);\n// Output: {key3: \"value3\", key1: \"value1\", key2: \"value2\"}\n```\n\nIn this example, the object2 is created by spreading the properties of object1 into a new object. The result is an object that contains the properties of both object1 and object2.\n\nYou can also use the spread operator to override properties of the original object, like this:\n\n```{.js} \nlet object1 = {\n  key1: 'value1',\n  key2: 'value2'\n};\n\nlet object2 = {\n  ...object1,\n  key1: 'new value'\n};\n\nconsole.log(object2);\n// Output: {key1: \"new value\", key2: \"value2\"}\n``` \nIn this example, the key1 property of object1 is overridden by the key1 property of object2.\n\nYou can also use the spread operator to merge multiple objects into a single object, like this:\n\n```{.js}\nlet object1 = {\n  key1: 'value1'\n};\n\nlet object2 = {\n  key2: 'value2'\n};\n\nlet object3 = {\n  key3: 'value3'\n};\n\nlet mergedObject = {\n  ...object1,\n  ...object2,\n  ...object3\n};\n\nconsole.log(mergedObject);\n// Output: {key1: \"value1\", key2: \"value2\", key3: \"value3\"}\n\n\n```\n\n## Object Assign \n\nObject.assign() is a method in JavaScript that is used to copy the values of all enumerable own properties from one or more source objects to a target object. It returns the target object.\n\nHere are some examples of how to use Object.assign():\n\n```{.js} \nlet object1 = {\n  key1: 'value1',\n  key2: 'value2'\n};\n\nlet object2 = {\n  key3: 'value3'\n};\n\nlet targetObject = Object.assign({}, object1, object2);\n\nconsole.log(targetObject);\n// Output: {key1: \"value1\", key2: \"value2\", key3: \"value3\"}\n\nExample 2. \n\nlet object1 = {\n  key1: 'value1'\n};\n\nlet object2 = {\n  key2: 'value2'\n};\n\nlet object3 = {\n  key3: 'value3'\n};\n\nlet mergedObject = Object.assign({}, object1, object2, object3);\n\nconsole.log(mergedObject);\n// Output: {key1: \"value1\", key2: \"value2\", key3: \"value3\"}\n\n\n```\n>  It is a useful method for copying and merging objects in JavaScript, and it is often used in combination with other features such as destructuring and the rest/spread operator (...).\n\n## Object destructing \n\nObject destructuring is a syntax in JavaScript that allows you to extract properties from an object and assign them to variables. It is a convenient way to extract data from objects and can be used in combination with other features such as the spread operator (...) and the rest/spread operator (...).\n\nHere is an example of object destructuring:\n\n```{.js}\nlet object = {\n  key1: 'value1',\n  key2: 'value2',\n  key3: 'value3'\n};\n\nlet {key1, key2} = object;\n\nconsole.log(key1); // Output: 'value1'\nconsole.log(key2); // Output: 'value2'\n```\n\n\nYou can also use object destructuring to assign the extracted properties to variables with different names, like this:\n\n```{.js}\nlet {key1: newKey1, key2: newKey2} = object;\n\nconsole.log(newKey1); // Output: 'value1'\nconsole.log(newKey2); // Output: 'value2'\n```\nYou can also use object destructuring in combination with the spread operator (...) to extract some properties and spread the rest into a new object, like this:\n\n```{.js}\nlet {key1, ...rest} = object;\n\nconsole.log(key1); // Output: 'value1'\nconsole.log(rest); // Output: {key2: \"value2\", key3: \"value3\"}\n```\n\n## Understanding this keyword \n\nIn JavaScript, the this keyword refers to the current object that is being executed. It is a special keyword that is used to access properties and methods of the current object.\n\nThe value of this depends on how the function is called, and it can change depending on the context.\n\nHere is an example of how this is used in a simple function:\n\n```{.js}\nfunction greet() {\n  console.log(`Hello, ${this.name}!`);\n}\n\nlet person = {\n  name: 'John',\n  greet: greet\n};\n\nperson.greet(); // Output: \"Hello, John!\"\n```\nIn this example, the greet function is called as a method of the person object, so the value of this inside the function is the person object. As a result, the name property of the person object is accessed and logged to the console.\n\nThe value of this can also be determined by how the function is called. For example:\n\n```{.js} \nlet object = {\n  name: 'John'\n};\n\nfunction greet() {\n  console.log(`Hello, ${this.name}!`);\n}\n\ngreet.call(object); // Output: \"Hello, John!\"\n\n```\nIn this example, the call() method is used to call the greet function with a specific value for this. The call() method accepts an object as its first argument, which is used as the value of this inside the function.\n\nThe value of this can also be bound to a specific value using the bind() method:\n\n```{.js} \nlet object = {\n  name: 'John'\n};\n\nfunction greet() {\n  console.log(`Hello, ${this.name}!`);\n}\n\nlet boundGreet = greet.bind(object);\nboundGreet(); // Output: \"Hello, John!\"\n``` \nIn this example, the bind() method is used to create a new function, boundGreet, that has its value of this permanently bound to the object.\n\n\n> We used few keywords like call, apply and bind, lets explore what each of them works \n\n1. Call()\n\n    The call() method takes a function and an argument list (a comma-separated list of arguments) as its arguments, and calls the function with the specified arguments and the value of this set to the first argument.\n\n    Here is an example of how to use the call() method:\n\n    ```{.js} \n    let object = {\n    name: 'John'\n    };\n\n    function greet(greeting) {\n    console.log(`${greeting}, ${this.name}!`);\n    }\n\n    greet.call(object, 'Hello'); // Output: \"Hello, John!\"\n\n    ```\n    In this example, the call() method is used to call the greet function with the object as the value of this and the 'Hello' string as the greeting argument.\n\n2. Apply()\n\n    The apply() method is similar to the call() method, but it takes a function and an array of arguments as its arguments, rather than a list of arguments.\n\n    Here is an example of how to use the apply() method:\n\n    ```{.js}  \n    let object = {\n    name: 'John'\n    };\n\n    function greet(greeting) {\n    console.log(`${greeting}, ${this.name}!`);\n    }\n\n    greet.apply(object, ['Hello']); // Output: \"Hello, John!\"\n    ```\n\n3. Bind()\n\nIn JavaScript, the bind() method is a function method that creates a new function with a specific value for this. The new function is called a bound function.\n\nThe bind() method takes an object as its first argument, which becomes the value of this inside the bound function. It also accepts additional arguments that are passed to the bound function as arguments when it is called.\n\nHere is an example of how to use the bind() method:\n\n```{.js} \nlet object = {\n  name: 'John'\n};\n\nfunction greet(greeting) {\n  console.log(`${greeting}, ${this.name}!`);\n}\n\nlet boundGreet = greet.bind(object, 'Hello');\nboundGreet(); // Output: \"Hello, John!\"\n\n```\n\nIn this example, the bind() method is used to create a new function, boundGreet, that has its value of this permanently bound to the object. The 'Hello' string is also passed as an argument to the bind() method, and it becomes the first argument of the bound function when it is called.\n\nThe bind() method is often used to create functions with a fixed value of this, which can be useful in cases where you need to pass a function as a callback or when you want to bind a method to an object.\n\nKeep in mind that the bind() method does not call the function immediately. It only creates a new function that can be called later. To call the function immediately, you can use the call() or apply() methods.\n\nFor example:\n\n```{.js} \nlet object = {\n  name: 'John'\n};\n\nfunction greet(greeting) {\n  console.log(`${greeting}, ${this.name}!`);\n}\n\ngreet.call(object, 'Hello'); // Output: \"Hello, John!\"\n\n```\n\n## This and Arrow Function \n\nIn JavaScript, the value of this inside an arrow function is determined by the surrounding context. Arrow functions do not have their own this value, so the value of this inside an arrow function is the same as the value of this in the surrounding context.\n\nHere is an example of an arrow function that uses the this keyword:\n\n```{.js} \nlet object = {\n  name: 'John',\n  greet: () => {\n    console.log(`Hello, ${this.name}!`);\n  }\n};\n\nobject.greet(); // Output: \"Hello, undefined!\"\n``` \nIn this example, the greet method is an arrow function that uses the this keyword to access the name property of the surrounding object. However, because arrow functions do not have their own this value, the value of this inside the function is undefined.\n\nTo fix this, you can use a regular function instead of an arrow function:\n\n``` {.js} \nlet object = {\n  name: 'John',\n  greet: function() {\n    console.log(`Hello, ${this.name}!`);\n  }\n};\n\nobject.greet(); // Output: \"Hello, John!\"\n\n```\nIn this example, the greet method is a regular function that has its own this value, which is determined by the surrounding context. As a result, the name property of the object is accessed correctly.\n\n> Keep in mind that arrow functions are often used as a concise syntax for functions, but they have some differences in behavior compared to regular functions, such as the way they handle the this keyword. It is important to understand these differences and use the appropriate type of function for your specific needs.\n\n## Getters and Setters on Object \n\n\nIn JavaScript, getters and setters are methods that allow you to get and set the value of an object property, respectively. They are a convenient way to define custom behavior for getting and setting the value of a property, and they can be used to create read-only or write-only properties, as well as to validate or transform the value of a property.\n\nHere is an example of how to use getters and setters:\n\n```{.js} \nlet object = {\n  _property: 'value',\n  get property() {\n    return this._property;\n  },\n  set property(value) {\n    this._property = value;\n  }\n};\n\nconsole.log(object.property); // Output: \"value\"\nobject.property = 'new value';\nconsole.log(object.property); // Output: \"new value\"\n```\nIn this example, the property getter and setter are defined as methods with the get and set keywords, respectively. The getter is used to get the value of the _property property, and the setter is used to set the value of the _property property.\n\nTo use a getter or setter, you can use the property name as if it were a normal property, without calling the method. For example, object.property is used to get the value of the property getter, and object.property = value is used to set the value of the property setter.\n\nGetters and setters can be used to create read-only or write-only properties by omitting the getter or setter, respectively. For example:\n\n```{.js} \nlet object = {\n  _property: 'value',\n  get property() {\n    return this._property;\n  }\n};\n\nconsole.log(object.property); // Output: \"value\"\nobject.property = 'new value';\nconsole.log(object.property); // Output: \"value\"\n```\n\nIn this example, the property getter is defined, but the property setter is omitted, which makes the property a read-only property.\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true,"caption":"See code"},"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"toc-depth":3,"number-sections":false,"html-math-method":"katex","reference-location":"margin","output-file":"Object.html"},"language":{"code-summary":"Show the code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","theme":{"light":"cosmo","dark":"darkly"},"toc-location":"right","code-copy":"hover","smooth-scroll":true,"anchor-sections":true,"fig-cap-location":"margin","footnotes-hover":true,"citations-hover":true},"extensions":{"book":{"multiFile":true}}}}}