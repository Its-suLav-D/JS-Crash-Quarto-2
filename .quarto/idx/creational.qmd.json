{"title":"Creational","markdown":{"yaml":{"title":"Creational"},"headingText":"Builder Pattern","containsRefs":false,"markdown":"\n\n\n\n\nThe builder pattern is a type of creational pattern that helps in building complex objects using simpler objects. It provides a flexible and step-by-step approach towards making these objects. It also keeps the representation and process of creation shielded.\n\n\nConsider the example of a restaurant that has to build a meal for its customers. The building process has various stages:\n\n1. The customer comes in and places an orders for a meal to the cashier\n\n2. The cashier forwards the order to the crew member (the builder) who makes the order\n\n3. The builder assembles the meal consisting of the burger, fries, and soda of choice\n\n4. The cashier receives the final meal from the builder\n\n5. The customer receives the final order from the cashier\n\nEvery meal ordered by the customer regardless of the choices for the burger, fries, and soda will follow the same process. As you can see, a complex object is created following a step-by-step process.\n\n```{.js}\nfunction Meal() {\n  this.make = function(builder){\n    builder.step1();\n    builder.step2();\n    builder.step3();\n    builder.step4();\n    return builder.get();\n  }\n}\nfunction MealBuilder(pattie,side,soda) {\n   this.meal = null;\n   this.step1 = function() {\n        this.meal = new Order();\n    };\n    this.step2 = function() {\n        this.meal.addBurger(pattie);\n    };\n    this.step3 = function(){\n      this.meal.addSide(side);\n    }\n    this.step4 = function(){\n      this.meal.addSoda(soda);\n    }\n    this.get = function() {\n        return this.meal;\n    };\n}\nfunction Order() {\n    this.burger = null;\n    this.side = null;\n    this.soda = null;\n    this.addBurger = function(pattie) {\n        this.burger = pattie;\n    };\n    this.addSide = function(side) {\n        this.side = side;\n    };\n    this.addSoda = function(soda){\n      this.soda = soda;\n    }\n    this.display = function(){\n      console.log(`You meal has a ${this.burger} burger, ${this.side} on the side, and a ${this.soda}.`)\n    }\n}\nvar meal = new Meal();\nvar mealBuilder = new MealBuilder(\"chicken\",\"curly fries\",\"coke\");\nvar chickenBurgerMeal = meal.make(mealBuilder);\nchickenBurgerMeal.display();\n```\n\n---\n\n## When to use the builder pattern?\n\nYou can use this design pattern when building apps that require you to create complex objects. It can help you hide the construction process of building these objects.\n\nA good example would be a DOM, where you might need to create plenty of nodes and attributes. The construction process can get quite messy if you are building a complex DOM object. In cases like these, the builder pattern can be used.\n\n## Gamma Categorization\n\nGamma categorization is a software design pattern that involves organizing code into categories based on their level of abstraction. The pattern is named after Erich Gamma, one of the authors of the book \"Design Patterns: Elements of Reusable Object-Oriented Software\".\n\nThe idea behind gamma categorization is to group code into categories based on their level of abstraction, with the most abstract code at the top and the most concrete code at the bottom. This can make it easier to understand the structure of a codebase and navigate between different levels of abstraction.\n\nHere's an example of how gamma categorization might be applied in JavaScript:\n\n```{.js\n// Most abstract\nclass Document {\n  constructor(text) {\n    this.text = text;\n  }\n  getText() {\n    return this.text;\n  }\n}\n// Less abstract\nclass DocumentViewer {\n  constructor(document) {\n    this.document = document;\n  }\n  display() {\n    console.log(this.document.getText());\n  }\n}\nclass DocumentEditor {\n  constructor(document) {\n    this.document = document;\n  }\n  edit(text) {\n    this.document.text = text;\n  }\n}\n// Most concrete\nclass FileDocument extends Document {\n  constructor(filePath) {\n    super();\n    this.filePath = filePath;\n  }\n  getText() {\n    // Read text from a file at the specified file path\n  }\n}\nclass WebDocument extends Document {\n  constructor(url) {\n    super();\n    this.url = url;\n  }\n  getText() {\n    // Read text from a web page at the specified URL\n  }\n}\n```\n\nIn this example, the most abstract code is at the top (the Document class), followed by the less abstract code (the DocumentViewer and DocumentEditor classes), and finally the most concrete code (the FileDocument and WebDocument classes).\n\nThis organization makes it clear that the DocumentViewer and DocumentEditor classes depend on the abstract Document class, and that the FileDocument and WebDocument classes are concrete implementations of the Document class.\n\n## BUILDER DESIGN PATTERN\n\nThe builder design pattern is a software design pattern that separates the construction of a complex object from its representation, allowing you to construct the object step by step. This can be useful when you need to create an object that has a large number of possible configurations or when you want to separate the construction of an object from the code that uses it.\n\nHere's an example of how the builder design pattern might be applied in JavaScript:\n\n```{.js\nclass User {\n  constructor(builder) {\n    this.name = builder.name;\n    this.email = builder.email;\n    this.age = builder.age;\n    this.phone = builder.phone;\n    this.address = builder.address;\n  }\n}\nclass UserBuilder {\n  constructor(name) {\n    this.name = name;\n  }\n  withEmail(email) {\n    this.email = email;\n    return this;\n  }\n  withAge(age) {\n    this.age = age;\n    return this;\n  }\n  withPhone(phone) {\n    this.phone = phone;\n    return this;\n  }\n  withAddress(address) {\n    this.address = address;\n    return this;\n  }\n  build() {\n    return new User(this);\n  }\n}\nconst user = new UserBuilder('John')\n  .withEmail('john@example.com')\n  .withAge(30)\n  .withPhone('123-456-7890')\n  .withAddress('123 Main St.')\n  .build();\nconsole.log(user);\n// Output: User { name: 'John', email: 'john@example.com', age: 30, phone: '123-456-7890', address: '123 Main St.' }\n```\n\n## Builder Facet\n\nIn the context of the builder design pattern in JavaScript, a \"facet\" is a property or feature of an object that can be constructed using the builder pattern. For example, in the previous examples, the User and Product classes had several facets (such as name, email, age, price, description, color, and size) that could be set using the UserBuilder and ProductBuilder classes, respectively.\n\nThe builder pattern allows you to construct an object with a large number of facets in a flexible and modular way. You can set each facet separately, and you can choose which facets to set and which to leave unset. This can be useful when you need to create an object with a large number of possible configurations.\n\n```{.js\nclass Product {\n  constructor(builder) {\n    this.name = builder.name;\n    this.price = builder.price;\n    this.description = builder.description;\n    this.color = builder.color;\n    this.size = builder.size;\n  }\n}\nclass ProductBuilder {\n  constructor(name) {\n    this.name = name;\n  }\n  withPrice(price) {\n    this.price = price;\n    return this;\n  }\n  withDescription(description) {\n    this.description = description;\n    return this;\n  }\n  withColor(color) {\n    this.color = color;\n    return this;\n  }\n  withSize(size) {\n    this.size = size;\n    return this;\n  }\n  build() {\n    return new Product(this);\n  }\n}\nconst product = new ProductBuilder('Shirt')\n  .withPrice(19.99)\n  .withDescription('A soft, comfortable shirt')\n  .withColor('blue')\n  .withSize('XL')\n  .build();\nconsole.log(product);\n// Output: Product { name: 'Shirt', price: 19.99, description: 'A soft, comfortable shirt', color: 'blue', size: 'XL' }\n```\n\n# Factory Pattern\n\nThe factory pattern is a creational pattern that provides a template that can be used to create objects. It is used in complex situations where the type of the object required varies and needs to be specified in each case.\n\nIt does not use the new keyword directly to instantiate objects. This means it does not explicitly require the use of a constructor to create objects. Instead, it provides a generic interface that delegates the object creation responsibility to the corresponding subclass.\n\n```{.js}\nclass IceCreamFactory {\n  constructor() {\n    this.createIcecream = function(flavor) {\n      let iceCream;\n      if (flavor === 'chocolate'){\n          iceCream = new Chocolate();\n      }\n      else if (flavor === 'mint'){\n          iceCream = new Mint();\n      }\n      else if (flavor === 'strawberry'){\n          iceCream = new Strawberry();\n      }\n      return iceCream;\n    };\n  }\n}\nclass Chocolate {\n  constructor() {\n    this.icecreamFlavor = \"chocolate\";\n    this.message = function() {\n      return `You chose the ${this.icecreamFlavor} flavor.`;\n    };\n  }\n}\nclass Mint {\n  constructor() {\n    this.icecreamFlavor = \"mint\";\n    this.message = function() {\n      return `You chose the ${this.icecreamFlavor} flavor.`;\n    };\n  }\n}\nclass Strawberry{\n  constructor() {\n    this.icecreamFlavor = \"strawberry\";\n    this.message = function() {\n      return `You chose the ${this.icecreamFlavor} flavor.`;\n    };\n  }\n}\n// creating objects\nconst iceCreamfactory = new IceCreamFactory();\nconst chocolate = iceCreamfactory.createIcecream('chocolate');\nconst mint = iceCreamfactory.createIcecream('mint');\nconst strawberry = iceCreamfactory.createIcecream('strawberry');\nconsole.log(chocolate.message());\nconsole.log(mint.message());\nconsole.log(strawberry.message());\n```\n\n---\n\n## When to use the factory pattern?\n\n1. When the type of objects required cannot be anticipated beforehand\n\n2. When multiple objects that share similar characteristics need to be created\n\n3. When you want to generalize the object instantiation process since the object set up is complex in nature\n\n## Factory\n\nA component responsible solely for the wholesale(not piecewise) creation of objects. The factory method design pattern is a software design pattern that defines an interface for creating an object, but lets subclasses decide which class to instantiate. The factory method pattern allows a class to defer instantiation to subclasses.\n\n```{.js}\nclass Document {\n  constructor(text) {\n    this.text = text;\n  }\n  getText() {\n    return this.text;\n  }\n}\nclass DocumentFactory {\n  createDocument(type) {\n    if (type === 'txt') {\n      return new TxtDocument();\n    } else if (type === 'docx') {\n      return new DocxDocument();\n    } else {\n      throw new Error('Invalid document type');\n    }\n  }\n}\nclass TxtDocument extends Document {\n  constructor() {\n    super();\n  }\n  getText() {\n    // Read text from a .txt file\n  }\n}\nclass DocxDocument extends Document {\n  constructor() {\n    super();\n  }\n  getText() {\n    // Read text from a .docx file\n  }\n}\nconst factory = new DocumentFactory();\nconst txtDocument = factory.createDocument('txt');\nconsole.log(txtDocument.getText());\nconst docxDocument = factory.createDocument('docx');\nconsole.log(docxDocument.getText());\n```\n\n## Abstract Factory\n\nThe abstract factory design pattern is a software design pattern that provides an interface for creating families of related or dependent objects without specifying their concrete classes.\n\nThe abstract factory pattern is similar to the factory method pattern, but it allows you to create families of objects rather than just individual objects. This can be useful when you need to create a group of related objects that have a common theme or that can work together in some way.\n\n```{.js}\nclass Document {\n  constructor(text) {\n    this.text = text;\n  }\n  getText() {\n    return this.text;\n  }\n}\nclass DocumentFactory {\n  createDocument(type) {\n    if (type === 'txt') {\n      return new TxtDocument();\n    } else if (type === 'docx') {\n      return new DocxDocument();\n    } else {\n      throw new Error('Invalid document type');\n    }\n  }\n}\nclass TxtDocument extends Document {\n  constructor() {\n    super();\n  }\n  getText() {\n    // Read text from a .txt file\n  }\n}\nclass DocxDocument extends Document {\n  constructor() {\n    super();\n  }\n  getText() {\n    // Read text from a .docx file\n  }\n}\nclass DocumentEditor {\n  constructor(documentFactory) {\n    this.documentFactory = documentFactory;\n  }\n  openDocument(type) {\n    return this.documentFactory.createDocument(type);\n  }\n}\nconst factory = new DocumentFactory();\nconst editor = new DocumentEditor(factory);\nconst txtDocument = editor.openDocument('txt');\nconsole.log(txtDocument.getText());\nconst docxDocument = editor.openDocument('docx');\nconsole.log(docxDocument.getText());\n```"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true,"caption":"See code"},"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"toc-depth":3,"number-sections":false,"html-math-method":"katex","reference-location":"margin","output-file":"creational.html"},"language":{"code-summary":"Show the code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","theme":{"light":"cosmo","dark":"darkly"},"toc-location":"right","code-copy":"hover","smooth-scroll":true,"anchor-sections":true,"fig-cap-location":"margin","footnotes-hover":true,"citations-hover":true,"title":"Creational"},"extensions":{"book":{"multiFile":true}}}}}