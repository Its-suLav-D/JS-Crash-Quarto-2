{"title":"Functions","markdown":{"headingText":"Functions","containsRefs":false,"markdown":"\nIn JavaScript, a function is a block of code that can be defined and called by a name. Functions are a fundamental building block of the language, and are used to perform reusable tasks or to abstract complex logic.\n\n---\n\n## Pure and Impure Functions \n\na pure function is a function that always returns the same output for a given set of inputs, and has no side effects. This means that a pure function does not modify any variables outside of its own scope, and does not make any external requests or perform any other actions that could affect the state of the program.\n\nHere is an example of a pure function:\n\n```{.js}\nfunction add(a, b) {\n  return a + b;\n}\n\nconst sum = add(1, 2);\nconsole.log(sum); // Output: 3\n\n\n```\n\nOn the other hand, an impure function is a function that has side effects or depends on variables outside of its own scope. This means that an impure function may return different output for the same set of inputs, or may modify variables or perform other actions that affect the state of the program.\n\nHere is an example of an impure function:\n\n```{.js}\nlet counter = 0;\n\nfunction incrementCounter() {\n  counter++;\n}\n\nincrementCounter();\nconsole.log(counter); // Output: 1\nincrementCounter();\nconsole.log(counter); // Output: 2\n\n\n```\n\n> Note: Pure functions are generally considered to be easier to test and debug, as they do not depend on external state and always produce the same output for a given set of inputs. Impure functions, on the other hand, may be more difficult to test and debug, as they may have unexpected side effects and may produce different output for the same set of inputs.\n\n\n--- \n\n## Factory Functions \n\n\n factory function is a function that returns a new object or value, typically based on some input or configuration. Factory functions are often used to create objects or values that are similar, but not exactly the same, and can be a useful way to encapsulate complex logic or reduce duplication in your code.\n\nHere is an example of a simple factory function that returns a new object with a name property:\n\n```{.js}\nfunction createPerson(name) {\n  return {\n    name: name\n  };\n}\n\n```\n\nconst person1 = createPerson('John');\nconst person2 = createPerson('Mary');\n\nconsole.log(person1.name); // Output: \"John\"\nconsole.log(person2.name); // Output: \"Mary\"\n\nIn this example, the createPerson() function takes a single argument, name, and returns a new object with a name property set to the value of the name argument. The function is called twice with different arguments, resulting in two different objects being created.\n\nFactory functions can be used to create a wide variety of objects or values, and can be especially useful when you need to create multiple similar objects or values that may have slightly different properties or behaviors.\n\nMore Exammples: A factory function that generates graduates \n\n```{.js}\nfunction createGraduate(name, degree) {\n  return {\n    name: name,\n    degree: degree,\n    sayHello: function() {\n      console.log(`Hello, my name is ${this.name} and I have a degree in ${this.degree}.`);\n    }\n  };\n}\n\nfunction createGraduates(schoolName, graduates) {\n  return graduates.map(graduate => createGraduate(graduate.name, graduate.degree));\n}\n\nconst schoolGraduates = createGraduates('My School', [\n  { name: 'John', degree: 'Computer Science' },\n  { name: 'Mary', degree: 'Business Administration' },\n  { name: 'Alice', degree: 'Art History' }\n]);\n\nschoolGraduates.forEach(graduate => graduate.sayHello());\n\n// Output:\n// \"Hello, my name is John and I have a degree in Computer Science.\"\n// \"Hello, my name is Mary and I have a degree in Business Administration.\"\n// \"Hello, my name is Alice and I have a degree in Art History.\"\n\n```\n\n> Classes and Factory Functions Relation \n\n```{.js}\nclass Student{\n    constructor(name, degree)\n    {\n        this.name = name; \n        this.degree= degree;\n    }\n    sayHello()\n    {\n         console.log(`Hello, my name is ${this.name} and I have a degree in ${this.degree}.`);\n    }\n}\n\nfunction createGraduate(name, degree)\n{\n    return new Student(name, degree);\n}\n\nconst student1 = createGraduate('Sulav', 'Machine Learning');\nconst student2 = createGraduate('Sam', 'CIT')\n\nstudent1.sayHello(); \nstudent2.sayHello(); \n\n```\n\n---\n\n## Callback Functions \n\nA callback function is a function that is passed as an argument to another function, and is executed after the outer function has completed. Callback functions are a common pattern in JavaScript, and are used to handle asynchronous events or to perform additional tasks after a function has completed.\n\nHere is an example of a simple callback function:\n\n```{.js}\nfunction greet(name, callback) {\n  console.log(`Hello, ${name}!`);\n  callback();\n}\n\nfunction sayGoodbye() {\n  console.log('Goodbye!');\n}\n\ngreet('John', sayGoodbye);\n// Output: \"Hello, John!\"\n//         \"Goodbye!\"\n\n```\nIn this example, the greet() function takes a name and a callback function as arguments, and logs a greeting message to the console. It then calls the callback function. The sayGoodbye() function is passed as the callback function, and is executed after the greet() function has completed.\n\nCallback functions are often used in JavaScript to handle asynchronous events, such as when making HTTP requests or waiting for a user to interact with a page. For example:\n\n```{.js}\nfunction makeRequest(url, callback) {\n  // Make the request and get the response\n\n```\n\nHere are few more examples of callback function:\n\n1. Handling User Input \n\n    ```{.js}\n    function handleInput(event, callback) {\n    console.log(`You entered: ${event.target.value}`);\n    callback();\n    }\n\n    function clearInput() {\n    document.getElementById('input').value = '';\n    }\n\n    document.getElementById('input').addEventListener('input', event => handleInput(event, clearInput));\n\n\n    ```\n    In this example, the handleInput() function takes an event object and a callback function as arguments, and logs the value of the input element to the console. It then calls the callback function. The clearInput() function is passed as the callback function, and is executed after the handleInput() function has completed.\n\n2. HTTP Request \n\n    ```{.js}\n    function makeRequest(url, callback) {\n    fetch(url)\n        .then(response => response.json())\n        .then(data => callback(data));\n    }\n\n    function displayData(data) {\n    console.log(data);\n    }\n\n    makeRequest('http://example.com/api/data', displayData);\n\n    ```\n    In this example, the makeRequest() function takes a URL and a callback function as arguments, and makes an HTTP request using the fetch() function. When the response is received, it is parsed as JSON and passed to the callback function. The displayData() function is passed as the callback function, and is executed after the makeRequest() function has completed, with the received data as an argument.\n\n3. Executing After Delay\n\n    ```{.js}\n    function doSomethingAfterDelay(callback, delay) {\n        setTimeout(callback, delay);\n    }\n\n    function sayHello() {\n        console.log('Hello!');\n    }\n\n    doSomethingAfterDelay(sayHello, 1000);\n    // Output: \"Hello!\" (after a 1 second delay)\n\n    ```\n\n--- \n\n## Closure \n\nA closure is a function that has access to the variables and scope of its outer function, even after the outer function has completed. Closures are created when a function is defined inside another function, and allow the inner function to access the variables and scope of the outer function.\n\nHere is an example of a closure in JavaScript:\n\n```{.js}\nfunction outerFunction(x) {\n  let y = x;\n\n  function innerFunction() {\n    console.log(y);\n  }\n\n  return innerFunction;\n}\n\nconst inner = outerFunction(5);\ninner(); // Output: 5\n\n```\n\nIn this example, the outerFunction() function takes a single argument, x, and defines a variable y with the value of x. It then defines an innerFunction() function, which logs the value of y to the console. The outerFunction() function returns the innerFunction() function, which is assigned to a variable called inner.\n\nWhen the inner() function is called, it has access to the variables and scope of the outerFunction(), even though the outerFunction() has already completed. In this case, the innerFunction() logs the value of y, which is 5.\n\nClosures are often used in JavaScript to create private variables or to create functions with specific context or state. For example, you might use a closure to create a function that has access to a specific set of data, or to create a function that can only be called a certain number of times. Closures can help you write more modular, reusable code, and can be a powerful tool in your JavaScript programming toolkit.\n\n\nHere are few more examples to understand closure\n\n```{.js}\nfunction createClassGreeting(className) {\n  const students = ['John', 'Mary', 'Alice', 'Bob'];\n\n  return function() {\n    students.forEach(student => console.log(`Hello, ${student}! You are enrolled in ${className}.`));\n  };\n}\n\nconst greetCSE341Students = createClassGreeting('CSE 341');\ngreetCSE341Students();\n\n// Output:\n// \"Hello, John! You are enrolled in CSE 341.\"\n// \"Hello, Mary! You are enrolled in CSE 341.\"\n// \"Hello, Alice! You are enrolled in CSE 341.\"\n// \"Hello, Bob! You are enrolled in CSE 341.\"\n\n\n```\n\nIn this example, the createClassGreeting() function takes a class name as an argument, and defines an array of students. It returns a function that iterates over the array of students and logs a greeting message to the console for each student.\n\nThe returned function has access to the className and students variables through the closure, even after the createClassGreeting() function has completed. When the returned function is called, it uses the className and students variables to generate the greeting messages for each student.\n---\n\n## Currying \n\nCurrying is the process of transforming a function with multiple arguments into a sequence of functions that each take a single argument. This is often used to create more specialized or reusable functions by binding some of the arguments to the function ahead of time.\n\nHere is an example of a function that uses currying:\n\nfunction add(x) {\n  return function(y) {\n    return x + y;\n  }\n}\n\nconst add10 = add(10);\nconsole.log(add10(5));  // Output: 15\nconsole.log(add10(15));  // Output: 25\n\nIn this example, the add function takes a single argument x and returns a new function that takes a single argument y. When the returned function is called with an argument, it adds x and y together and returns the result.\n\nWe can then use currying to create a new function add10 by calling add with the argument 10. This creates a new function that will always add 10 to its argument. We can then call add10 with different arguments to get the result of adding 10 to those arguments.\n\nCurrying can be useful for creating specialized functions or for partial application of arguments to a function. It can also be used to create more readable and expressive code by breaking down a function into smaller, more focused functions.\n\nMore Exmaple\n\n```{.js}\nconst fetchData = endpoint => params => {\n  return fetch(`${endpoint}?${new URLSearchParams(params)}`)\n    .then(response => response.json());\n};\n\nconst fetchUserData = fetchData('https://my-api.com/users');\nconst fetchProductData = fetchData('https://my-api.com/products');\n\nfetchUserData({id: 123}).then(user => console.log(user));\nfetchProductData({id: 456}).then(product => console.log(product));\n\n\n```\nIn this example, we have a fetchData function that takes an endpoint as its first argument and returns a new function that takes params as its argument. When the returned function is called with params, it makes a request to the specified endpoint with the provided parameters and returns the JSON response.\n\nWe can then use currying to create specialized versions of the fetchData function for fetching user data and product data by calling the fetchData function with the corresponding endpoint. We can then call these specialized functions with the desired parameters to make requests for specific data.\n\nThis approach allows us to reuse the same fetch logic for different endpoints, while also making it easier to read and understand the code by breaking it down into smaller, more focused functions."},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true,"caption":"See code"},"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"toc-depth":3,"number-sections":false,"html-math-method":"katex","reference-location":"margin","output-file":"function.html"},"language":{"code-summary":"Show the code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","theme":{"light":"cosmo","dark":"darkly"},"toc-location":"right","code-copy":"hover","smooth-scroll":true,"anchor-sections":true,"fig-cap-location":"margin","footnotes-hover":true,"citations-hover":true},"extensions":{"book":{"multiFile":true}}}}}