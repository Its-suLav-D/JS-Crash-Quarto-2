{"title":"Generators and Iterators","markdown":{"headingText":"Generators and Iterators","containsRefs":false,"markdown":"\nA generator is a special type of function that can be paused and resumed at any time, allowing you to execute code in a controlled, sequential manner. Generators are defined using the function* syntax, and can be used to create iterators or to implement asynchronous programming techniques.\n\nHere is an example to implement a async task queue \n\n```{.js}\nfunction* runTasks(tasks) {\n  for (let task of tasks) {\n    yield executeTask(task);\n  }\n}\n\nfunction executeTask(task) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(`Executing task: ${task}`);\n      resolve();\n    }, 1000);\n  });\n}\n\nconst tasks = ['Task 1', 'Task 2', 'Task 3'];\nconst taskRunner = runTasks(tasks);\n\nfunction runNextTask() {\n  let result = taskRunner.next();\n  if (!result.done) {\n    result.value.then(() => runNextTask());\n  }\n}\n\nrunNextTask();\n\n\n```\n\nIn this example, the runTasks() generator function takes an array of tasks as an argument, and yields a promise for each task that is returned by the executeTask() function. The executeTask() function simulates the execution of a task by returning a promise that resolves after a 1 second delay.\n\nThe runNextTask() function uses the generator object returned by the runTasks() generator function to execute the tasks in sequence. It calls the next() method on the generator object to retrieve the next task, and waits for the task's promise to resolve before calling itself again to execute the next task. This process continues until all tasks have been executed, or until the generator function has completed.\n\nGenerators can be a useful tool for creating asynchronous programs that are easy to understand and maintain. They can help you write code that is more modular and reusable, and can make it easier to manage the flow of data in your programs.\n\nMore Examples\n\n```{.js}\nfunction* greetStudents(students) {\n  for (let student of students) {\n    yield `Hello, ${student.name}! You are enrolled in CSE 341.`;\n    yield `Your assignment for this week is ${student.assignment}.`;\n  }\n}\n\nconst students = [\n  { name: 'John', assignment: 'Homework 1' },\n  { name: 'Mary', assignment: 'Homework 2' },\n  { name: 'Alice', assignment: 'Homework 3' },\n  { name: 'Bob', assignment: 'Homework 4' }\n];\n\nconst studentGreeting = greetStudents(students);\n\nconsole.log(studentGreeting.next().value); // Output: \"Hello, John! You are enrolled in CSE 341.\"\nconsole.log(studentGreeting.next().value); // Output: \"Your assignment for this week is Homework 1.\"\nconsole.log(studentGreeting.next().value); // Output: \"Hello, Mary! You are enrolled in CSE 341.\"\nconsole.log(studentGreeting.next().value); // Output: \"Your assignment for this week is Homework 2.\"\nconsole.log(studentGreeting.next().value); // Output: \"Hello, Alice! You are enrolled in CSE 341.\"\nconsole.log(studentGreeting.next().value\n\n```\n\n---\n\n## Iterator \n\nAn iterator is an object that allows you to access and iterate over the elements of a collection, such as an array or an object. An iterator has a next() method that returns the next element in the collection, along with a done property that indicates whether the iterator has reached the end of the collection.\n\nIterators are typically used with the for-of loop, which automatically calls the next() method on the iterator and terminates the loop when the done property is true.\n\nHere is an example of using an iterator to iterate over the elements of an array:\n\n```{.js}\nconst fruits = ['apple', 'banana', 'mango'];\n\nconst fruitIterator = fruits[Symbol.iterator]();\nconsole.log(fruitIterator.next()); // Output: { value: \"apple\", done: false }\nconsole.log(fruitIterator.next()); // Output: { value: \"banana\", done: false }\nconsole.log(fruitIterator.next()); // Output: { value: \"mango\", done: false }\nconsole.log(fruitIterator.next()); // Output: { value: undefined, done: true }\n\n\n```\n\nIn this example, the fruits array has a built-in iterator that can be accessed using the Symbol.iterator symbol. The iterator's next() method returns an object with a value property that holds the current element in the array, and a done property that indicates whether the iterator has reached the end of the array.\n\nYou can also create your own iterators"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true,"caption":"See code"},"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"toc-depth":3,"number-sections":false,"html-math-method":"katex","reference-location":"margin","output-file":"generator.html"},"language":{"code-summary":"Show the code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","theme":{"light":"cosmo","dark":"darkly"},"toc-location":"right","code-copy":"hover","smooth-scroll":true,"anchor-sections":true,"fig-cap-location":"margin","footnotes-hover":true,"citations-hover":true},"extensions":{"book":{"multiFile":true}}}}}