{"title":"ModernJs","markdown":{"yaml":{"title":"ModernJs"},"headingText":"Arrow Function","containsRefs":false,"markdown":"\n\n\nA more concise function syntax, particularly useful for replacing short anonymous functions. The basic syntax for an arrow function is:\n\n```{.js}\n(param1, param2) => {\n    clapHand(param1, param2);\n    return 'This worked';\n}\n```\n\nHowever, if an arrow function only requires one line, then the curly braces and return keywords can be removed. Additionally, when these are used inline such as for a call to the array map function, the semicolon must be removed. Finally, if there is only one parameter, the parantheses around the parameter can also be removed. For example, this code will create and array with the values doubled:\n\n```{.js}\n[1,2,3,4].map(num => num * 2);\n```\n\nThere are few constratins to arrow functions which will be explored througouht the course. The most important of these is that arrow fucntions do not have their own <mark> this </mark> binding. Additionally,arrow functions cannot be used as a constructors or generators.\n\n## Destructuring Assignment\n\n> Array Destructuring\n\n```{.js}\nconst [fist, second] = [1,2,3];\nconsole.log(first) // 1\nconsole.log(second) // 2\n\n```\n\n> When destructuring object it can also be renamed\n\n```{.js}\nconst car = {\n    color: white,\n    model: Dodge,\n    vin: 123123123123,\n    engine: []\n}\n\nconst {color: dodgeColor, model: isDodge} = car\n\nconsole.log(dodgeColor) // white\nconsole.log(isDodge) // model\n\n```\n\n> Destructuring can also be used in a function parameter, for example\n\n```{.js}\nfunction displayName({name}) {\n    console.log(name)\n}\n\n```\n\n## Rest Operator\n\nA javascript operator using ... for condensing multiple elements into a single array. This uses the same synatx as the spread operator, but funtionality is essentially the opposite.\n\nRest syntax can be used in both arrays and objects to get all of the values not being destructured. For example:\n\n```{.js}\n\nconst floffy = [\"Hey\", \"Floppy\", \"is\", \"my\", \"best friend\", \".\"]\nconst [firstWord, secondWord, ...rem] = floffy // ..rem is [\"is\", \"my\", \"best friend\", \".\"]\n\n// Rest on Object\n\nconst {key1, key2, ...rem} = car //  ...rem is {vin: value, engine:[]}\n\n```\n\n## Spread Operator\n\nIn JavaScript, the spread operator (...) is a syntax that allows you to expand an iterable object (such as an array or a string) into a list of its individual elements. It is often used in combination with other features such as destructuring and the rest/spread operator (...).\n\nHere is an example of how to use the spread operator:\n\n``` {.js}\nlet array1 = [1, 2, 3];\nlet array2 = [...array1, 4, 5];\n\nconsole.log(array2); // Output: [1, 2, 3, 4, 5]\n```\nIn this example, the spread operator is used to expand the elements of the array1 into a list, which is then combined with the 4 and 5 elements to create a new array, array2.\n\nThe spread operator can also be used to spread the elements of an array into the arguments of a function, like this:\n\n```{.js}\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nlet array = [1, 2, 3];\n\nconsole.log(sum(...array)); // Output: 6\n\n```\nIn this example, the spread operator is used to spread the elements of the array into the arguments of the sum function, which adds them together and returns the result.\n\n## Template Literal \n\nIn JavaScript, a template literal is a way to define a string that spans multiple lines and can contain expressions. Template literals are surrounded by backticks (`), rather than single or double quotes.\n\nHere is an example of a template literal that spans multiple lines and includes an expression:\n\n```{.js}\nconst name = 'Bob';\nconst age = 30;\n\nconst message = `Hello, my name is ${name} and I am ${age} years old.`;\n// Output: \"Hello, my name is Bob and I am 30 years old.\"\n```\nIn this example, the name and age variables are interpolated into the string using the ${} syntax. This is known as string interpolation.\n\nTemplate literals also allow you to define strings that span multiple lines, which can be useful for creating longer, more readable strings.\n\n```{.js}\nconst html = `\n<div>\n  <h1>Hello, World!</h1>\n  <p>This is a paragraph</p>\n</div>\n`;\n\n```\nTemplate literals were introduced in JavaScript as part of the ES6 (ECMAScript 6) specification. They provide a more powerful and flexible way to define strings compared to traditional string literals.\n\n## Null Coalescing \n\nIn JavaScript, the null coalescing operator (??) is a logical operator that returns the first operand if it exists and is not null, or the second operand if the first operand is either null or undefined. It is a shorthand way of writing a conditional expression that checks for null or undefined.\n\nHere is an example of using the null coalescing operator:\n\n```{.js}\nconst user = { name: 'Bob' };\n\nconst username = user.name ?? 'Guest';\n// Output: \"Bob\"\n``` \nIn this example, the username variable is assigned the value of user.name if it exists and is not null, or the string 'Guest' if user.name is either null or undefined.\n\nHere is the same example written using a conditional expression:\n\n```{.js}\nconst username = user.name !== null && user.name !== undefined ? user.name : 'Guest';\n\n```\nThe null coalescing operator can be useful when you want to provide a default value for a variable that might be null or undefined. It can also be used to simplify code by reducing the need for nested conditional expressions.\n\nThe null coalescing operator was introduced in JavaScript as part of the ES2020 (ECMAScript 2020) specification. It is supported in modern browsers and can be used with transpilers like Babel to support older browsers.\n\n## Optional Chaining \n\nIn JavaScript, optional chaining is a feature that allows you to access an object's properties, methods, or elements without having to check for null or undefined values. It is a shorthand way of writing a series of checks to see if an object, property, or element exists before trying to access it.\n\nHere is an example of using optional chaining to access an object's property:\n\n```{.js}\nconst user = { name: 'Bob' };\n\nconst username = user?.name;\n// Output: \"Bob\"\n\n```\nIn this example, the username variable is assigned the value of user.name if user exists and is not null or undefined. If user is null or undefined, the value of username will be undefined.\n\nHere is the same example written without optional chaining:\n\n```{.js}\nlet username;\nif (user && user.name) {\n  username = user.name;\n}\n``` \nOptional chaining can be useful when you want to access properties or elements of an object that may not exist, or when you are working with data that may be null or undefined. It can also help to simplify code by reducing the need for nested conditional statements.\n\nOptional chaining was introduced in JavaScript as part of the ES2020 (ECMAScript 2020) specification. It is supported in modern browsers and can be used with transpilers like Babel to support older browsers.\n\n\n## Short Circuit Evaulation \n\nIn JavaScript, short-circuit evaluation is a feature that allows you to use logical operators (such as && and ||) to evaluate expressions and determine the value of a boolean expression. It is called \"short-circuit\" evaluation because the second operand is only evaluated if the first operand is not sufficient to determine the value of the expression.\n\nHere is an example of short-circuit evaluation using the && operator:\n\n``` {.js}\nconst user = { name: 'Bob' };\n\nconst username = user && user.name;\n// Output: \"Bob\"\n```\nIn this example, the username variable is assigned the value of user.name if user exists and is not null or undefined. If user is null or undefined, the value of username will be undefined. This is because the && operator only evaluates the second operand (user.name) if the first operand (user) is truthy.\n\nHere is the same example written without short-circuit evaluation:\n\n``` {.js}\nlet username;\nif (user) {\n  username = user.name;\n}\n```\nShort-circuit evaluation can be useful for reducing the number of conditional statements in your code, and for simplifying complex boolean expressions.\n\n> Note that short-circuit evaluation is only possible with the && and || operators. It is not possible with the & and | operators, which always evaluate both operands regardless of the value of the first operand.\n\n|| operator only needs one expression to be true, if the left side is true then the right side will not be evaluated. This is quite the opposite of the && operator. For example, \n``` {.js}\ntrue || myFunc() // doesn't call myFunc\nfalse || myFunc() // calls myFunc \n\n```"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true,"caption":"See code"},"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"toc-depth":3,"number-sections":false,"html-math-method":"katex","reference-location":"margin","output-file":"modern.html"},"language":{"code-summary":"Show the code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","theme":{"light":"cosmo","dark":"darkly"},"toc-location":"right","code-copy":"hover","smooth-scroll":true,"anchor-sections":true,"fig-cap-location":"margin","footnotes-hover":true,"citations-hover":true,"title":"ModernJs"},"extensions":{"book":{"multiFile":true}}}}}