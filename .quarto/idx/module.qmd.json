{"title":"Module","markdown":{"headingText":"Module","containsRefs":false,"markdown":"\nA module is a self-contained piece of code that exports a specific set of features or values, and can be imported and used by other modules. Modules allow you to organize your code into reusable chunks and can help you to better manage the dependencies and interactions between different parts of your application.\n\nThere are several ways to create and use modules in JavaScript. One common approach is to use the export and import statements, which are part of the ECMAScript (ES) module system.\n\nHere is an example of exporting a value from a module:\n```{.js}\n// math.js\n\nexport const PI = 3.14;\n\nexport function calculateCircumference(radius) {\n  return 2 * PI * radius;\n}\n\n```\n\nIn this example, the math.js module exports the PI constant and the calculateCircumference() function, which can be imported and used by other modules.\n\nHere is an example of importing a value from a module:\n```{.js}\n// main.js\n\nimport { PI, calculateCircumference } from './math';\n\nconsole.log(PI); // Output: 3.14\nconsole.log(calculateCircumference(5)); // Output: 31.4\n```\nIn this example, the main.js module imports the PI constant and the calculateCircumference() function from the math module, and uses them to perform some calculations.\n\nYou can also use the export default statement to specify a default export for a module, which can be imported using the import statement without the curly braces. For example:\n```{.js}\n// math.js\n\nexport default function add(x, y) {\n  return x + y;\n}\n```\n\n```{.js}\n// main.js\n\nimport add from './math';\n\nconsole.log(add(2, 3)); // Output: 5\n\n```\n\nIn this example, the math.js module exports a default function that can be imported and used by the main.js module without the need to specify a named export.\n\nModules can help you to organize and modularize your code, and can make it easier to manage dependencies and interactions between different parts of your application. They can also help you to create reusable components that can be shared and imported by multiple modules, making it easier to build and maintain complex applications.\n\n---\n\n## Immediately-invoked Function Expression (IIFE \n\nIn JavaScript, an immediately-invoked function expression (IIFE) is a function that is defined and immediately executed, without being stored in a variable or assigned to a property. IIFEs are often used to create private scopes, to hide variables and functions from the global scope, and to prevent name collisions with other variables and functions.\n\nAn IIFE is defined using the function expression syntax, followed by parentheses and a pair of curly braces. The function is invoked by adding a pair of parentheses after the function definition.\n\n```{.js}\n(function() {\n  let secret = '123456';\n\n  function getSecret() {\n    return secret;\n  }\n\n  function setSecret(newSecret) {\n    secret = newSecret;\n  }\n\n  window.secretModule = {\n    getSecret: getSecret,\n    setSecret: setSecret\n  };\n})();\n\nconsole.log(secretModule.getSecret()); // Output: \"123456\"\nsecretModule.setSecret('abcdef');\nconsole.log(secretModule.getSecret()); // Output: \"abcdef\"\n\n\n```\nIn this example, the IIFE creates a private scope and defines the secret variable and the getSecret() and setSecret() functions. It then exports these functions to the global scope by assigning them to the secretModule object, which can be accessed by other parts of the application.\n\nThe secret variable is not accessible from the global scope, and cannot be modified directly. Instead, it can only be accessed and modified using the getSecret() and setSecret() functions, which are exported by the IIFE. This allows you to create a secure, private scope for storing sensitive data, and to control access to that data using well-defined interfaces.\n\nIIFEs can be a useful tool for organizing and modularizing your code, and for creating private scopes that can help you to manage dependencies and interactions between different parts of your application. They can also help you to prevent name collisions and to keep"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":{"source":false,"toggle":true,"caption":"See code"},"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"toc-depth":3,"number-sections":false,"html-math-method":"katex","reference-location":"margin","output-file":"module.html"},"language":{"code-summary":"Show the code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.313","theme":{"light":"cosmo","dark":"darkly"},"toc-location":"right","code-copy":"hover","smooth-scroll":true,"anchor-sections":true,"fig-cap-location":"margin","footnotes-hover":true,"citations-hover":true},"extensions":{"book":{"multiFile":true}}}}}