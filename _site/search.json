[
  {
    "objectID": "function.html",
    "href": "function.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "In JavaScript, a function is a block of code that can be defined and called by a name. Functions are a fundamental building block of the language, and are used to perform reusable tasks or to abstract complex logic.\n\n\n\na pure function is a function that always returns the same output for a given set of inputs, and has no side effects. This means that a pure function does not modify any variables outside of its own scope, and does not make any external requests or perform any other actions that could affect the state of the program.\nHere is an example of a pure function:\nfunction add(a, b) {\n  return a + b;\n}\n\nconst sum = add(1, 2);\nconsole.log(sum); // Output: 3\n\nOn the other hand, an impure function is a function that has side effects or depends on variables outside of its own scope. This means that an impure function may return different output for the same set of inputs, or may modify variables or perform other actions that affect the state of the program.\nHere is an example of an impure function:\nlet counter = 0;\n\nfunction incrementCounter() {\n  counter++;\n}\n\nincrementCounter();\nconsole.log(counter); // Output: 1\nincrementCounter();\nconsole.log(counter); // Output: 2\n\n\nNote: Pure functions are generally considered to be easier to test and debug, as they do not depend on external state and always produce the same output for a given set of inputs. Impure functions, on the other hand, may be more difficult to test and debug, as they may have unexpected side effects and may produce different output for the same set of inputs.\n\n\n\n\n\nfactory function is a function that returns a new object or value, typically based on some input or configuration. Factory functions are often used to create objects or values that are similar, but not exactly the same, and can be a useful way to encapsulate complex logic or reduce duplication in your code.\nHere is an example of a simple factory function that returns a new object with a name property:\nfunction createPerson(name) {\n  return {\n    name: name\n  };\n}\nconst person1 = createPerson(‘John’); const person2 = createPerson(‘Mary’);\nconsole.log(person1.name); // Output: “John” console.log(person2.name); // Output: “Mary”\nIn this example, the createPerson() function takes a single argument, name, and returns a new object with a name property set to the value of the name argument. The function is called twice with different arguments, resulting in two different objects being created.\nFactory functions can be used to create a wide variety of objects or values, and can be especially useful when you need to create multiple similar objects or values that may have slightly different properties or behaviors.\nMore Exammples: A factory function that generates graduates\nfunction createGraduate(name, degree) {\n  return {\n    name: name,\n    degree: degree,\n    sayHello: function() {\n      console.log(`Hello, my name is ${this.name} and I have a degree in ${this.degree}.`);\n    }\n  };\n}\n\nfunction createGraduates(schoolName, graduates) {\n  return graduates.map(graduate => createGraduate(graduate.name, graduate.degree));\n}\n\nconst schoolGraduates = createGraduates('My School', [\n  { name: 'John', degree: 'Computer Science' },\n  { name: 'Mary', degree: 'Business Administration' },\n  { name: 'Alice', degree: 'Art History' }\n]);\n\nschoolGraduates.forEach(graduate => graduate.sayHello());\n\n// Output:\n// \"Hello, my name is John and I have a degree in Computer Science.\"\n// \"Hello, my name is Mary and I have a degree in Business Administration.\"\n// \"Hello, my name is Alice and I have a degree in Art History.\"\n\nClasses and Factory Functions Relation\n\nclass Student{\n    constructor(name, degree)\n    {\n        this.name = name; \n        this.degree= degree;\n    }\n    sayHello()\n    {\n         console.log(`Hello, my name is ${this.name} and I have a degree in ${this.degree}.`);\n    }\n}\n\nfunction createGraduate(name, degree)\n{\n    return new Student(name, degree);\n}\n\nconst student1 = createGraduate('Sulav', 'Machine Learning');\nconst student2 = createGraduate('Sam', 'CIT')\n\nstudent1.sayHello(); \nstudent2.sayHello(); \n\n\n\n\nA callback function is a function that is passed as an argument to another function, and is executed after the outer function has completed. Callback functions are a common pattern in JavaScript, and are used to handle asynchronous events or to perform additional tasks after a function has completed.\nHere is an example of a simple callback function:\nfunction greet(name, callback) {\n  console.log(`Hello, ${name}!`);\n  callback();\n}\n\nfunction sayGoodbye() {\n  console.log('Goodbye!');\n}\n\ngreet('John', sayGoodbye);\n// Output: \"Hello, John!\"\n//         \"Goodbye!\"\nIn this example, the greet() function takes a name and a callback function as arguments, and logs a greeting message to the console. It then calls the callback function. The sayGoodbye() function is passed as the callback function, and is executed after the greet() function has completed.\nCallback functions are often used in JavaScript to handle asynchronous events, such as when making HTTP requests or waiting for a user to interact with a page. For example:\nfunction makeRequest(url, callback) {\n  // Make the request and get the response\nHere are few more examples of callback function:\n\nHandling User Input\nfunction handleInput(event, callback) {\nconsole.log(`You entered: ${event.target.value}`);\ncallback();\n}\n\nfunction clearInput() {\ndocument.getElementById('input').value = '';\n}\n\ndocument.getElementById('input').addEventListener('input', event => handleInput(event, clearInput));\n\nIn this example, the handleInput() function takes an event object and a callback function as arguments, and logs the value of the input element to the console. It then calls the callback function. The clearInput() function is passed as the callback function, and is executed after the handleInput() function has completed.\nHTTP Request\nfunction makeRequest(url, callback) {\nfetch(url)\n    .then(response => response.json())\n    .then(data => callback(data));\n}\n\nfunction displayData(data) {\nconsole.log(data);\n}\n\nmakeRequest('http://example.com/api/data', displayData);\nIn this example, the makeRequest() function takes a URL and a callback function as arguments, and makes an HTTP request using the fetch() function. When the response is received, it is parsed as JSON and passed to the callback function. The displayData() function is passed as the callback function, and is executed after the makeRequest() function has completed, with the received data as an argument.\nExecuting After Delay\nfunction doSomethingAfterDelay(callback, delay) {\n    setTimeout(callback, delay);\n}\n\nfunction sayHello() {\n    console.log('Hello!');\n}\n\ndoSomethingAfterDelay(sayHello, 1000);\n// Output: \"Hello!\" (after a 1 second delay)\n\n\n\n\n\nA closure is a function that has access to the variables and scope of its outer function, even after the outer function has completed. Closures are created when a function is defined inside another function, and allow the inner function to access the variables and scope of the outer function.\nHere is an example of a closure in JavaScript:\nfunction outerFunction(x) {\n  let y = x;\n\n  function innerFunction() {\n    console.log(y);\n  }\n\n  return innerFunction;\n}\n\nconst inner = outerFunction(5);\ninner(); // Output: 5\nIn this example, the outerFunction() function takes a single argument, x, and defines a variable y with the value of x. It then defines an innerFunction() function, which logs the value of y to the console. The outerFunction() function returns the innerFunction() function, which is assigned to a variable called inner.\nWhen the inner() function is called, it has access to the variables and scope of the outerFunction(), even though the outerFunction() has already completed. In this case, the innerFunction() logs the value of y, which is 5.\nClosures are often used in JavaScript to create private variables or to create functions with specific context or state. For example, you might use a closure to create a function that has access to a specific set of data, or to create a function that can only be called a certain number of times. Closures can help you write more modular, reusable code, and can be a powerful tool in your JavaScript programming toolkit.\nHere are few more examples to understand closure\nfunction createClassGreeting(className) {\n  const students = ['John', 'Mary', 'Alice', 'Bob'];\n\n  return function() {\n    students.forEach(student => console.log(`Hello, ${student}! You are enrolled in ${className}.`));\n  };\n}\n\nconst greetCSE341Students = createClassGreeting('CSE 341');\ngreetCSE341Students();\n\n// Output:\n// \"Hello, John! You are enrolled in CSE 341.\"\n// \"Hello, Mary! You are enrolled in CSE 341.\"\n// \"Hello, Alice! You are enrolled in CSE 341.\"\n// \"Hello, Bob! You are enrolled in CSE 341.\"\n\nIn this example, the createClassGreeting() function takes a class name as an argument, and defines an array of students. It returns a function that iterates over the array of students and logs a greeting message to the console for each student.\nThe returned function has access to the className and students variables through the closure, even after the createClassGreeting() function has completed. When the returned function is called, it uses the className and students variables to generate the greeting messages for each student.\n\n\n\n\nCurrying is the process of transforming a function with multiple arguments into a sequence of functions that each take a single argument. This is often used to create more specialized or reusable functions by binding some of the arguments to the function ahead of time.\nHere is an example of a function that uses currying:\nfunction add(x) { return function(y) { return x + y; } }\nconst add10 = add(10); console.log(add10(5)); // Output: 15 console.log(add10(15)); // Output: 25\nIn this example, the add function takes a single argument x and returns a new function that takes a single argument y. When the returned function is called with an argument, it adds x and y together and returns the result.\nWe can then use currying to create a new function add10 by calling add with the argument 10. This creates a new function that will always add 10 to its argument. We can then call add10 with different arguments to get the result of adding 10 to those arguments.\nCurrying can be useful for creating specialized functions or for partial application of arguments to a function. It can also be used to create more readable and expressive code by breaking down a function into smaller, more focused functions.\nMore Exmaple\nconst fetchData = endpoint => params => {\n  return fetch(`${endpoint}?${new URLSearchParams(params)}`)\n    .then(response => response.json());\n};\n\nconst fetchUserData = fetchData('https://my-api.com/users');\nconst fetchProductData = fetchData('https://my-api.com/products');\n\nfetchUserData({id: 123}).then(user => console.log(user));\nfetchProductData({id: 456}).then(product => console.log(product));\n\nIn this example, we have a fetchData function that takes an endpoint as its first argument and returns a new function that takes params as its argument. When the returned function is called with params, it makes a request to the specified endpoint with the provided parameters and returns the JSON response.\nWe can then use currying to create specialized versions of the fetchData function for fetching user data and product data by calling the fetchData function with the corresponding endpoint. We can then call these specialized functions with the desired parameters to make requests for specific data.\nThis approach allows us to reuse the same fetch logic for different endpoints, while also making it easier to read and understand the code by breaking it down into smaller, more focused functions."
  },
  {
    "objectID": "array.html",
    "href": "array.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "In JavaScript, an array is an ordered collection of data items, which can be of any data type. Arrays are a very useful data structure in programming, and they are used to store and manage large amounts of data efficiently.\n\n\nThere are bunch of ways to create an array in javascript. Below are some of the examples to acheive it.\nconst arr = [10] \nThe Array constructor is a function that creates and initializes an array object. It is used to create an array with a specified length, or to create an array from an array-like object or iterable.\nconst arr = Array(341) // Create empty Array [ <341 empty items> ]\nconst arr = Array(341, 2) // Creates Array of length 2 [341, 2]\nconst arr = new Array(341)\nconst arr = ['CSE'] \nconst arr = Array('CSE') // Creats Array of length 1 ['CSE']\nconst arr = new Array('CSE', 'Love') // Creeats Array of length 2 ['CSE', 'Love']\nArray.of() is a static method that creates a new Array instance with a variable number of arguments, regardless of the number of arguments or their type.\nThe Array.of() method is similar to the Array constructor, but it creates an array with the given arguments as its elements, rather than creating an empty array with a specified length.\nconst arr = Array.of(341) // Creates Array of Length 1 [ 341 ]\nconst arr = Array.of('CSE', 341) // Creates Array of Length 2 ['CSE', 341]\nArray.from() is a static method that creates a new, shallow-copied Array instance from an array-like or iterable object. It takes an iterable object, like an array, or a string, and returns a new Array object with the elements of the iterable.\nHere is an example of using Array.from() to create an array from a string:\nconst arr = Array.from('CSE 341')\nconsole.log(arr) // ['C','S', 'E', ' ', '3', '4', '1']\n\n\n\n\nPush()\n\npush() is a method that adds one or more elements to the end of an array and returns the new length of the array.\nHere is an example of using push() to add an element to an array:\nconst arr = [1, 2, 3];\narr.push(4);\nconsole.log(arr); // [1, 2, 3, 4]\n\nPop()\n\npop() is a method that removes the last element from an array and returns the removed element.\nHere is an example of using pop() to remove the last element from an array:\nconst arr = [1, 2, 3];\nconst last = arr.pop();\nconsole.log(last); // 3\nconsole.log(arr); // [1, 2]\n\nShift()\n\nshift() is a method that removes the first element from an array and returns the removed element.\nHere is an example of using shift() to remove the first element from an array:\nconst arr = [1, 2, 3];\nconst first = arr.shift();\nconsole.log(first); // 1\nconsole.log(arr); // [2, 3]\n\nunShift()\n\nunshift() is a method that adds one or more elements to the beginning of an array and returns the new length of the array.\nHere is an example of using unshift() to add an element to the beginning of an array:\nconst arr = [1, 2, 3];\narr.unshift(0);\nconsole.log(arr); // [0, 1, 2, 3]\nsplice() is a method that adds, removes, or replaces elements in an array. It takes three arguments: the index at which to start making changes, the number of elements to remove (if any), and the elements to add (if any). It returns an array containing the removed elements.\nHere are some of the examples to remove, add, and copy\n// Remove an element from an array\nconst arr = [1, 2, 3, 4, 5];\nconst removed = arr.splice(2, 1);\nconsole.log(removed); // [3]\nconsole.log(arr); // [1, 2, 4, 5]\n// Add an element \nconst arr = [1, 2, 3, 4, 5];\narr.splice(2, 0, 3.5);\nconsole.log(arr); // [1, 2, 3.5, 3, 4, 5]\n// Create a shallow copy. It takes two arguments, the start index and the end index(exclusive)\nconst arr = [1, 2, 3, 4, 5];\nconst copy = arr.slice();\nconsole.log(copy); // [1, 2, 3, 4, 5]\n// Create a subarray from the middle of the array\nconst subarray = arr.slice(1, 4);\nconsole.log(subarray); // [2, 3, 4]\n// Create a subarray from the end of the array\nconst subarray2 = arr.slice(-2);\nconsole.log(subarray2); // [4, 5]\n// Create a subarray from the beginning of the array\nconst subarray3 = arr.slice(0, 2);\nconsole.log(subarray3); // [1, 2]\n\nconcat()\n\nconcat() is a method that returns a new array that consists of the elements in the original array, followed by the elements of one or more additional arrays or values. It does not modify the original array.\nHere are some of the examples:\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst merged = arr1.concat(arr2);\nconsole.log(merged); // [1, 2, 3, 4, 5, 6]\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst arr3 = [7, 8, 9];\nconst merged = arr1.concat(arr2, arr3, 10, 11, 12);\nconsole.log(merged); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n\nthe main difference between the concat() and push() methods is that concat() returns a new array, while push() modifies the original array and returns the new length of the array.\n\n\nindexOf() and lastIndexOf()\n\nThe indexOf() method searches for an element from the start of the array, and returns the first index at which the element can be found. If the element is not found, it returns -1.\nHere is an example of how to use the indexOf() method:\nlet array = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet index = array.indexOf(5);\nconsole.log(index); // Output: 4\nThe lastIndexOf() method, on the other hand, searches for an element from the end of the array, and returns the last index at which the element can be found. If the element is not found, it returns -1.\nHere is an example of how to use the lastIndexOf() method:\nlet array = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet index = array.lastIndexOf(5);\nconsole.log(index); // Output: 4\nBoth the indexOf and lastIndexOf methods accept a second argument, which specifies the index at which the search should start. For example:\nlet array = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet index = array.indexOf(5, 3);\nconsole.log(index); // Output: 4\nindex = array.lastIndexOf(5, 6);\nconsole.log(index); // Output: 4\n\nfind() and findIndex()\n\nThe find() and findIndex() methods in JavaScript are used to search for an element in an array that satisfies a given condition.\nThe find() method returns the first element in the array that satisfies the condition, or undefined if no such element is found.\nHere is an example of how to use the find() method:\nlet array = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet element = array.find(function(value) {\n  return value > 5;\n});\nconsole.log(element); // Output: 6\nThe findIndex() method, on the other hand, returns the index of the first element in the array that satisfies the condition, or -1 if no such element is found.\nHere is an example of how to use the findIndex() method:\nlet array = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet index = array.findIndex(function(value) {\n  return value > 5;\n});\nconsole.log(index); // Output: 5\nBoth the find() and findIndex() methods accept a callback function as an argument, which is called for each element in the array. The callback function should return a boolean value indicating whether the element satisfies the condition.\nYou can also use the find() and findIndex() methods with arrow functions, like this:\nlet array = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nlet element = array.find(value => value > 5);\nconsole.log(element); // Output: 6\nlet index = array.findIndex(value => value > 5);\nconsole.log(index); // Output: 5\n\njoin()\n\nThe join() method in JavaScript is a method of the Array object that allows you to join all the elements of an array into a single string.\nYou can use the join() method by calling it on an array, and passing a string as an argument. The string will be used as a separator between the elements of the array in the resulting string. If you omit the separator argument, the elements will be separated by a comma.\nHere is an example of how to use the join() method:\nlet array = ['I', 'love', 'JavaScript'];\nlet string = array.join(', ');\nconsole.log(string); // Output: \"I, love, JavaScript\"\nYou can also use the join() method with an empty string as a separator, like this:\nlet array = ['I', 'love', 'Js'];\nlet string = array.join('');\nconsole.log(string); // Output: \"IloveJs\"\nExample 2. Joining an array of objects with a semicolon\nlet array = [{a: 1}, {b: 2}, {c: 3}];\nlet string = array.join('; ');\nconsole.log(string); // Output: \"[object Object]; [object Object]; [object Object]\"\n\nKeep in mind that the join() method only works with arrays. If you try to use it on a non-array value, you will get an error.\n\n\nsplit()\n\nThe split() method in JavaScript is a method of the String object that allows you to split a string into an array of substrings based on a specific separator.\nYou can use the split() method by calling it on a string, and passing a separator string as an argument. The split() method will split the string at each occurrence of the separator, and return an array of substrings. If you omit the separator argument, the split() method will split the string at each occurrence of a whitespace character (such as a space, tab, or newline).\nHere is an example of how to use the split() method:\nlet string = \"apple, banana, orange\";\nlet array = string.split(', ');\nconsole.log(array); // Output: ['apple', 'banana', 'orange']\nExample 2. Use Regular Expression as a separator \nlet string = \"apple.banana.orange\";\nlet array = string.split(/\\./);\nconsole.log(array); // Output: ['apple', 'banana', 'orange']\n\n\n\nAlong with traditional ways i.e (for,while,do while) of iterating over array, we can leverage es6 array methods to make our life easier.\n\nforEach()\n\nforEach(): The forEach() method in JavaScript is a method of the Array object that allows you to iterate over the elements of an array and perform a specific action on each element. It does not return a new array, but instead operates on the original array.\nHere is an example of how to use the forEach() method:\nlet array = [1, 2, 3, 4, 5];\narray.forEach(function(value) {\n  console.log(value);\n});\n// 1\n// 2\n// 3\n// 4 \n// 5 \n\nmap()\n\nmap(): The map() method in JavaScript is a method of the Array object that allows you to transform the elements of an array into a new array. It returns a new array that is the result of calling a specific function on each element of the original array.\nHere is an example of how to use the map() method:\nlet array = [1, 2, 3, 4, 5];\nlet newArray = array.map(function(value) {\n  return value * 2;\n});\nconsole.log(newArray); // Output: [2, 4, 6, 8, 10]\nExample 2.  Using map() to extract the first letter of each element in an array\nlet array = ['apple', 'banana', 'orange'];\nlet newArray = array.map(function(value) {\n  return value[0];\n});\nconsole.log(newArray); // Output: ['a', 'b', 'o']\n\nreduce()\n\nThe reduce() method in JavaScript is a method of the Array object that allows you to reduce the elements of an array to a single value. It applies a specific function to each element of the array, and returns a single value that is the result of the function.\nHere is an example of how to use the reduce() method:\nlet array = [1, 2, 3, 4, 5];\nlet sum = array.reduce(function(accumulator, value) {\n  return accumulator + value;\n}, 0);\nconsole.log(sum); // Output: 15\n// Example2. Find Maximum value in array \nlet array = [5, 2, 3, 1, 4];\nlet max = array.reduce(function(accumulator, value) {\n  return Math.max(accumulator, value);\n}, -Infinity);\nconsole.log(max); // Output: 5\n\nfilter()\n\nThe filter() method in JavaScript is a method of the Array object that allows you to filter the elements of an array based on a specific condition. It returns a new array that contains only the elements of the original array that satisfy the condition.\nHere is an example of how to use the filter() method:\nlet array = [1, 2, 3, 4, 5];\nlet newArray = array.filter(function(value) {\n  return value % 2 === 0;\n});\nconsole.log(newArray); // Output: [2, 4]\n\nsort()\n\nThe sort() method in JavaScript is a method of the Array object that allows you to sort the elements of an array. It modifies the original array and returns it.\nHere is an example of how to use the sort() method:\nlet array = [5, 2, 3, 1, 4];\narray.sort();\nconsole.log(array); //\n\n\n\nThe spread operator (…) in JavaScript is a syntax that allows you to expand an iterable (such as an array or string) into individual elements.\nHere are some examples of how to use the spread operator:\n// Example 1: Adding elements to an array\nlet array1 = [1, 2, 3];\nlet array2 = [4, 5, 6];\nlet combinedArray = [...array1, ...array2];\nconsole.log(combinedArray); // Output: [1, 2, 3, 4, 5, 6]\n// Example 2: Passing elements of an array as arguments to a function\nlet array = [1, 2, 3];\nlet max = Math.max(...array);\nconsole.log(max); // Output: 3\n// Example 3: Copying an array\nlet array1 = [1, 2, 3];\nlet array2 = [...array1];\nconsole.log(array2); // Output: [1, 2, 3]\n\n\n\nDestructuring in JavaScript is a syntax that allows you to unpack values from arrays, or properties from objects, into distinct variables.\nHere are some examples of how to use destructuring with an array:\nlet array = [1, 2, 3, 4, 5];\nlet [a, b, c] = array;\nconsole.log(a); // Output: 1\nconsole.log(b); // Output: 2\nconsole.log(c); // Output: 3\nYou can also use destructuring with the rest operator (...) to capture the remaining elements of the array. For example:\nlet array = [1, 2, 3, 4, 5];\nlet [a, b, ...rest] = array;\nconsole.log(a); // Output: 1\nconsole.log(b); // Output: 2\nconsole.log(rest); // Output: [3, 4, 5]\nYou can also use destructuring to assign default values to variables, like this:\nlet array = [1];\nlet [a, b = 2] = array;\nconsole.log(a); // Output: 1\nconsole.log(b); // Output: 2\n\nI have found spread and destructuring super useful as it prevents from long nasty chaining\n\n\n\n\nA Set in JavaScript is a collection of unique values. It is similar to an array, but the values in a Set are not indexed, and the values must be unique.\nYou can create a Set by calling the Set constructor and passing an iterable (such as an array) as an argument, like this:\nlet set = new Set([1, 2, 3, 4, 5]);\nYou can also create an empty Set by calling the Set constructor without any arguments, like this:\nlet set = new Set();\nYou can add values to a Set using the add() method, like this:\nset.add(1);\nset.add(2);\nset.add(3);\nYou can remove values from a Set using the delete() method, like this:\nset.delete(2);\nYou can check if a Set contains a specific value using the has() method, like this:\nset.has(2); // Output: false\nset.has(3); // Output: true\nYou can iterate over the values in a Set using a for…of loop, like this:\nfor (let value of set) {\n  console.log(value);\n}\nYou can also use the size property to get the number of values in a Set, like this:\nconsole.log(set.size); // Output: 2"
  },
  {
    "objectID": "equality.html",
    "href": "equality.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "The most basic equality operator in JavaScript using ==. Loose equality compares values regardless of types following these steps:\n\n\n\nIf both values are either null or undefined, return true.\n\n\nConvert all booleans to numbers. True converts to 1 and false converts to 0.\n\n\nIf comparing a number to a string, convert the string to a number.\n\n\nIf comparing an object to a string, convert the object using its toString() or valueOf() methods.\n\n\nIf the types are the same, follow the same rules as strict equality.\n\n\n\nIn general, strict equality should be preferred due to it being easier to predict. However, loose equality can be useful for checking against null and undefined at once with value == null.\n\nLearn more: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality\n\n\n\n\nA JavaScript equality operator using ===. Strict equality compares both values and types following these steps:\n\n\n\nIf either value is NaN, return false.\n\n\nIf the values have different types, return false.\n\n\nIf both values are null or both values are undefined, return true.\n\n\nIf both values are objects, return true if they are the same object. False otherwise.\n\n\nIf both values are of the same primitive type, return true if the values are the same. False otherwise.\n\n\nLearn more: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality"
  },
  {
    "objectID": "variables.html",
    "href": "variables.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "A keyword for declaring a block-scoped variable that cannot be accessed before initialization.\n\n\n\n\n\nA keyword for declaring a function-scoped variable that is automatically initialized to undefined when it is hoisted.\n\n\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var\n\n\n\n\n\nA keyword for declaring a constant value. Constants have the same behavior as variables declared with let, except they cannot be reassigned.\n\n\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/Const\n\n\n\n\n\nThe behavior of a variable that is only accessible inside of the block it was defined. Most of the time, the block will simply be the nearest pair of curly braces to the declaration.\n\n\n\n\n\nThe behavior of a variable that is accessible anywhere inside of the function it was defined.\n\n\n\n\n\nThe process by which the JavaScript engine moves variable declarations to the top of their scope, allocating memory for them before reaching the line of code where they are declared. For variables declared with var, they are initialized to undefined until reaching the line of code that initializes the variable. For variables declared with let or const, the variable is not initialized and thus cannot be accessed before the line of code that initializes it. For example:\n\nconsole.log(testVar) // Undefined\nconsole.log(testLet) // reference error \n\nvar testVar = 10;\nlet testLet = 10; \n\nconsole.log(testVar) // 10 \nconsole.log(testlet) // 10"
  },
  {
    "objectID": "class.html",
    "href": "class.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "A class is a blueprint for creating objects that have the same properties and methods. Classes are a feature of the ECMAScript 2015 (ES6) version of JavaScript, and provide a way to define reusable and modular code that can be used to create objects with similar characteristics.\nClasses are defined using the class keyword, followed by the name of the class and a pair of curly braces. The body of the class can contain methods, which are functions that define the behavior of the class, and properties, which are variables that hold data associated with the class.\nHere is an example of a simple class that defines a Person class with a name property and a greet() method:\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\n\n\n\n\nConstructor: The constructor is a special method that is called when a new object is created from the class. It is used to initialize the object and to set up any required properties or state. The constructor is defined using the constructor keyword, and is invoked using the new operator.\nProperties: Properties are variables that hold data associated with the class. They can be defined as instance properties, which are unique to each object created from the class, or as static properties, which are shared by all objects created from the class. Properties are defined using the this keyword, and can be accessed and modified using the dot notation or the square bracket notation.\nMethods: Methods are functions that define the behavior of the class. They can be defined as instance methods, which are unique to each object created from the class, or as static methods, which are shared by all objects created from the class. Methods are defined using the function syntax, and can be called on objects using the dot notation or the square bracket notation.\n\n\n\n\n\n\nEncapsulation: Encapsulation is the process of bundling data and methods that operate on that data within a single unit, or object. It allows you to hide the implementation details of a class from other parts of your code, and to expose only the interface that is necessary for interacting with the object. Encapsulation helps to improve the maintainability and reusability of your code, and to prevent unintended side effects from external changes.\n\nclass Person {\nconstructor(name, age) {\n    this._name = name;\n    this._age = age;\n}\n\nget name() {\n    return this._name;\n}\n\nset name(newName) {\n    this._name = newName;\n}\n\nget age() {\n    return this._age;\n}\n\nset age(newAge) {\n    this._age = newAge;\n}\n}\n\nconst john = new Person('John', 30);\n\nconsole.log(john.name); // Output: \"John\"\nconsole.log(john.age); // Output: 30\n\njohn.name = 'Jane';\njohn.age = 35;\n\nconsole.log(john.name); // Output: \"Jane\"\nconsole.log(john.age); // Output: 35\nIn this example, the Person class has a name property and an age property, which are private variables that are defined using the underscore notation (_name and _age). The class also has get and set methods for accessing and modifying these properties, which are defined using the get and set keywords.\nBy using the get and set methods, you can control how the name and age properties are accessed and modified, and you can hide the implementation details of these properties from the rest of your code. For example, you can add validation or formatting logic to the set methods, or you can use the get methods to compute derived values from the name and age properties.\n\nAbstraction: Abstraction is the process of exposing only the relevant and essential features of an object, and hiding the implementation details. It allows you to focus on the essential characteristics of an object, and to ignore the unnecessary or irrelevant details. Abstraction helps to simplify the design and implementation of your code, and to make it more flexible and adaptable to change.\n\nclass PaymentMethod {\n  constructor(name) {\n    this.name = name;\n  }\n\n  charge(amount) {\n    throw new Error('charge() method must be implemented by a subclass');\n  }\n}\n\nclass CreditCard extends PaymentMethod {\n  constructor(name, cardNumber, expirationDate) {\n    super(name);\n    this.cardNumber = cardNumber;\n    this.expirationDate = expirationDate;\n  }\n\n  charge(amount) {\n    // Charge the credit card using the cardNumber and expirationDate\n  }\n}\n\nclass PayPal extends PaymentMethod {\n  constructor(name, email, password) {\n    super(name);\n    this.email = email;\n    this.password = password;\n  }\n\n  charge(amount) {\n    // Charge the PayPal account using the email and password\n  }\n}\n\nclass Cash extends PaymentMethod {\n  charge(amount) {\n    // Nothing to do, the payment has already been made in cash\n  }\n}\n\nconst paymentMethod = new CreditCard('John', '4111 1111 1111 1111', '01/23');\npaymentMethod.charge(100);\nIn this example, the PaymentMethod class is an abstract class that defines a common interface for different types of payment methods. It has a name property and a charge() method, which is an abstract method that does not have a concrete implementation.\nThe CreditCard, PayPal, and Cash classes are subclasses of the PaymentMethod class, and they all implement the charge() method with a concrete implementation. The CreditCard class has additional properties for storing the card number and expiration date, the PayPal class has additional properties for storing the email and password, and the Cash class does not have any additional properties.\nBy using abstraction, you can define a common interface for different types of payment methods, and you can hide the implementation details of each payment method behind the interface. This allows you to create more flexible and adaptable code, and to create more reusable and modular components.\nFor example, you can create a function that takes a payment method as an argument, and uses the charge() method to process the payment, without knowing the specific type of the payment method:\n    function processPayment(paymentMethod, amount) {\n        paymentMethod.charge\n    }); \n\nInheritance: Inheritance is a mechanism that allows one class to inherit the properties and methods of another class. It allows you to create a hierarchy of classes, where more specialized classes can inherit the characteristics and behavior of more general classes. Inheritance allows you to reuse and modify the code of existing classes, and to create new classes that are derived from existing ones.\n\nclass VendingMachine {\n  constructor(name, location) {\n    this.name = name;\n    this.location = location;\n    this.inventory = [];\n  }\n\n  addProduct(product) {\n    this.inventory.push(product);\n  }\n\n  getInventory() {\n    return this.inventory;\n  }\n}\n\nclass SoftDrinkVendingMachine extends VendingMachine {\n  constructor(name, location) {\n    super(name, location);\n  }\n\n  dispenseProduct(product) {\n    const index = this.inventory.indexOf(product);\n    if (index !== -1) {\n      this.inventory.splice(index, 1);\n      console.log(`Dispensing ${product.name}...`);\n    } else {\n      console.log(`Sorry, ${product.name} is out of stock.`);\n    }\n  }\n}\n\nclass SoftDrink {\n  constructor(name, flavor) {\n    this.name = name;\n    this.flavor = flavor;\n  }\n}\n\nconst vendingMachine = new SoftDrinkVendingMachine('Soda Machine', 'Lobby');\nvendingMachine.addProduct(new SoftDrink('Coke', 'Cola'));\nvendingMachine.addProduct(new SoftDrink('Sprite', 'Lemon-Lime'));\n\nconsole.log(vendingMachine.getInventory());\n// Output: [{ name: 'Coke', flavor: 'Cola' }, { name: 'Sprite', flavor: 'Lemon-Lime' }]\n\nvendingMachine.dispenseProduct(new SoftDrink('Coke', 'Cola'));\n// Output: \"Dispensing Coke...\"\n\nconsole.log(vendingMachine.getInventory());\n// Output: [{ name: 'Sprite', flavor: 'Lemon-Lime' }]\n\nvendingMachine.dispenseProduct(new SoftDrink('Coke', 'Cola'));\n// Output: \"Sorry, Coke is out of stock.\"\nIn this example, the VendingMachine class is a base class that defines a common interface for vending machines. It has a name property, a location property, and an inventory property that stores an array of products. It also has addProduct() and getInventory() methods for adding and accessing the products in the inventory.\nThe SoftDrinkVendingMachine class is a subclass of the VendingMachine class, and it inherits the name, location, and inventory properties from the base class. It also has a dispenseProduct() method that dispenses a product from the inventory, if it is available\n\nPolymorphism: Polymorphism is the ability of a single interface to operate on multiple data types. It allows you to write code that can handle different types of objects in a uniform way, without the need to know the specific type of each object at runtime. Polymorphism allows you to write more flexible and adaptable code, and to create more reusable and modular components.\n\nclass Shape {\n  constructor(color) {\n    this.color = color;\n  }\n\n  draw() {\n    throw new Error('draw() method must be implemented by a subclass');\n  }\n}\n\nclass Circle extends Shape {\n  constructor(color, radius) {\n    super(color);\n    this.radius = radius;\n  }\n\n  draw() {\n    console.log(`Drawing a ${this.color} circle with radius ${this.radius}...`);\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(color, width, height) {\n    super(color);\n    this.width = width;\n    this.height = height;\n  }\n\n  draw() {\n    console.log(`Drawing a ${this.color} rectangle with width ${this.width} and height ${this.height}...`);\n  }\n}\n\nfunction drawShapes(shapes) {\n  shapes.forEach(shape => shape.draw());\n}\n\nconst shapes = [new Circle('red', 5), new Rectangle('blue', 10, 20)];\ndrawShapes(shapes);\n// Output: \"Drawing a red circle with radius 5...\"\n//         \"Drawing a blue rectangle with width 10 and height 20...\"\n\nIn this example, the Shape class is a base class that defines a common interface for different types of shapes. It has a color property and a draw() method, which is an abstract method that does not have a concrete implementation.\nThe Circle and Rectangle classes are subclasses of the Shape class, and they both implement the draw() method with their own concrete implementation. The Circle class has additional properties for storing the radius, and the Rectangle class has additional properties for storing the width and height.\nThe drawShapes() function is a polymorphic function that takes an array of shapes as an argument, and uses the draw() method of each shape to draw it. Because the draw() method has different implementations for different types of shapes, the function can draw different types of shapes in a polymorphic way.\nBy using polymorphism, you can create a flexible and adaptable code, and you can create more reusable and modular components. You can define a common interface for different types of objects, and you can use the interface to interact with the objects in a polymorphic way, without knowing their specific type. This allows you to create more flexible and adaptable code, and to create more reusable and modular components.\nThese pillars form the foundation of the object-oriented programming (OOP) model in JavaScript, and allow you to organize and structure your code in a way that is flexible, reusable, and maintainable. By using encapsulation, abstraction, inheritance, and polymorphism, you can create a clear and consistent interface for interacting with objects, and create objects with similar characteristics and behavior.\nA real world Example that leverages all the OOPs concept\nclass Vehicle {\n  constructor(make, model) {\n    this._make = make;\n    this._model = model;\n  }\n  \n  get make() {\n    return this._make;\n  }\n  \n  set make(make) {\n    this._make = make;\n  }\n  \n  get model() {\n    return this._model;\n  }\n  \n  set model(model) {\n    this._model = model;\n  }\n  \n  start() {\n    console.log(`Starting vehicle: ${this._make} ${this._model}`);\n  }\n  \n  stop() {\n    console.log(`Stopping vehicle: ${this._make} ${this._model}`);\n  }\n}\n\nclass Car extends Vehicle {\n  constructor(make, model, numDoors) {\n    super(make, model);\n    this._numDoors = numDoors;\n  }\n  \n  get numDoors() {\n    return this._numDoors;\n  }\n  \n  set numDoors(numDoors) {\n    this._numDoors = numDoors;\n  }\n  \n  start() {\n    console.log(`Starting car: ${this._make} ${this._model}`);\n  }\n}\n\nclass Motorcycle extends Vehicle {\n  start() {\n    console.log(`Starting motorcycle: ${this._make} ${this._model}`);\n  }\n}\n\nconst car = new Car('Toyota', 'Camry', 4);\ncar.start();  // Output: \"Starting car: Toyota Camry\"\ncar.stop();   // Output: \"Stopping vehicle: Toyota Camry\"\n\nconst motorcycle = new Motorcycle('Honda', 'Civic');\nmotorcycle.start();  // Output: \"Starting motorcycle: Honda Civic\"\nmotorcycle.stop();   // Output: \"Stopping vehicle: Honda Civic\"\n\nconst vehicle = new Vehicle('Ford', 'F-150');\nvehicle.start();  // Output: \"Starting vehicle: Ford F-150\"\nvehicle.stop();   // Output: \"Stopping vehicle: Ford F-150\"\n\nconst vehicles = [car, motorcycle, vehicle];\nfor (const v of vehicles) {\n  console.log(`Make: ${v.make}, Model: ${v.model}`);\n}\nIn this example, we have a base Vehicle class that has a make and a model and can be started and stopped. The Vehicle class also has getters and setters to allow for encapsulation of the _make and _model properties.\nWe then have two subclasses: Car and Motorcycle, both of which inherit from Vehicle using the extends keyword. The Car class has an additional numDoors property, and both the Car and Motorcycle classes override the start method from the Vehicle class to provide their own implementation.\nFinally, we create instances of each of the classes and demonstrate polymorphism by storing them in an array and calling the same methods on each of them."
  },
  {
    "objectID": "event.html",
    "href": "event.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "Event-driven programming is a programming paradigm in which the flow of a program is determined by events that occur during the execution of the program. In an event-driven program, the program waits for a specific event to occur, such as a user clicking a button, and then executes a predetermined action in response to the event.\nEvent-driven programming is commonly used in graphical user interface (GUI) programming, where the program responds to user input events such as mouse clicks, key presses, and touch gestures. It is also used in network programming, where the program responds to network events such as incoming connections or data.\nIn JavaScript, event-driven programming is implemented using event listeners, which are functions that are registered to be called in response to a specific event. For example, an event listener can be added to a button element to execute a function when the button is clicked:\n<!-- HTML document -->\n<button id=\"my-button\">Click me</button>\n\n<script>\n  // Retrieve the button element\n  const button = document.getElementById('my-button');\n\n  // Add an event listener to the button\n  button.addEventListener('click', () => {\n    // Execute this function when the button is clicked\n    console.log('Button clicked');\n  });\n</script>\nIn this example, the addEventListener() method is used to add an event listener to the button element that listens for the click event. When the button is clicked, the event listener function is executed, which logs a message to the console.\nEvent-driven programming is a powerful way to build interactive and responsive programs, and is an important concept in modern programming languages and frameworks.\n\nIn JavaScript, the addEventListener() method is used to register an event listener on an HTML or XML element. The addEventListener() method takes three arguments: the event type, the event listener function, and an options object. The options object can contain three optional properties: capture, once, and passive.\nHere is an example of using addEventListener() with the options object:\n<button id=\"my-button\">Click me</button>\n\n<script>\n  // Retrieve the button element\n  const button = document.getElementById('my-button');\n\n  // Add an event listener to the button\n  button.addEventListener('click', () => {\n    // Execute this function when the button is clicked\n    console.log('Button clicked');\n  }, {\n    // Set the options object\n    capture: true, // Capture the event in the capturing phase\n    once: true, // Remove the event listener after it is called\n    passive: true // Indicate that the event listener is passive (doesn't call preventDefault)\n  });\n</script>\nIn this example, the event listener is registered to execute the function when the button element is clicked. The options object is set with the capture, once, and passive properties, which have the following effects:\ncapture: If set to true, the event listener is registered in the capturing phase of the event propagation, which means it is called before the event reaches the target element. If set to false (the default), the event listener is registered in the bubbling phase, which means it is called after the event reaches the target element.\n\nonce: If set to true, the event listener is removed after it is called for the first time. If set to false (the default), the event listener remains registered and can be called multiple times.\n\npassive: If set to true, the event listener is marked as passive, which means it does not call the preventDefault() method on the event object. If set to false (the default), the event listener can call preventDefault() if necessary.\n\nThese options can be useful in optimizing the performance of event listeners and fine-tuning the behavior of event-driven programs.\n\nNote: The signal property is not a part of the addEventListener() options object. The signal property is a part of the AbortSignal interface, which is used to provide a way to abort asynchronous tasks in JavaScript.\n\n\n\nEvent propagation, also known as event bubbling, is the process by which events are propagated from the target element to the ancestor elements in the DOM (Document Object Model) tree. In JavaScript, event propagation consists of two phases: the capturing phase and the bubbling phase.\nDuring the capturing phase, the event travels from the root element of the document (the window object) down to the target element. During the bubbling phase, the event travels from the target element back up to the root element.\nEvent propagation is useful for allowing multiple event listeners to be registered on different elements in the DOM tree, and for enabling events to be handled at different levels of the tree. For example, an event listener can be registered on the root element to handle all events that occur in the document, or on a specific element to handle only events that occur within that element.\nHere is an example of event propagation:\n<div id=\"my-div\">\n  <button id=\"my-button\">Click me</button>\n</div>\n\n<script>\n  // Retrieve the button element\n  const button = document.getElementById('my-button');\n\n  // Add an event listener to the button in the capturing phase\n  button.addEventListener('click', () => {\n    console.log('Button clicked (capturing)');\n  }, { capture: true });\n\n  // Add an event listener to the div element in the bubbling phase\n  const div = document.getElementById('my-div');\n  div.addEventListener('click', () => {\n    console.log('Button clicked (bubbling)');\n  });\n</script>\nIn this example, two event listeners are registered on the button and div elements. The first event listener is registered on the button element in the capturing phase, and the second event listener is registered on the div element in the bubbling phase.\nWhen the button element is clicked, the event is first propagated through the capturing phase, and the event listener registered on the button element is called. The event then propagates through the bubbling phase, and the event listener registered on the div element is called. The result is that both event listeners are called in the order that they were registered.\nEvent propagation allows multiple event listeners to be registered on different elements in the DOM tree, and enables events to be handled at different levels of the tree. It is an important concept in event-driven programming and is used in many modern programming languages and frameworks.\n\n\n\n\nEvent delegation is a technique in JavaScript that involves using a single event listener on a parent element to handle events that are triggered by its child elements. This technique can be useful for optimizing the performance of event-driven programs, particularly when dealing with large or dynamic sets of elements that require event handling.\nIn event delegation, the parent element is used as a “delegate” for the events that are triggered by its child elements. The event listener is registered on the parent element, and the event handling logic is implemented in the event listener function. When an event is triggered by a child element, the event listener function is called and can determine the target element that triggered the event based on the event object.\nHere is an example of using event delegation in JavaScript:\n\n<ul id=\"my-list\">\n  <li class=\"my-item\">Item 1</li>\n  <li class=\"my-item\">Item 2</li>\n  <li class=\"my-item\">Item 3</li>\n</ul>\n\n<script>\n  // Retrieve the list element\n  const list = document.getElementById('my-list');\n\n  // Add an event listener to the list element\n  list.addEventListener('click', (event) => {\n    // Check if the event target is an item element\n    if (event.target.matches('.my-item')) {\n      console.log('Item clicked');\n    }\n  });\n</script>\nIn this example, an event listener is registered on the list element using the addEventListener() method. The event listener function is called when any element within the list element is clicked, and the event object is passed to the function as an argument. The function uses the matches() method to check if the event target (the element that was clicked) is a li element with the class my-item, and if it is, it logs a message to the console.\nEvent delegation allows a single event listener to handle events triggered by multiple elements, and can be a useful technique for optimizing the performance of event-driven programs. It is often used in combination with other DOM manipulation methods and technologies such as HTML, CSS, and JavaScript libraries or frameworks."
  },
  {
    "objectID": "promise.html",
    "href": "promise.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "In JavaScript, a promise is an object that represents the eventual completion or failure of an asynchronous operation. Promises provide a way to handle asynchronous operations in a structured and composable way, and are a key concept in modern JavaScript programming. A promise can be in one of three states:\n- Pending: This is the initial state of a promise, and indicates that the asynchronous operation has not yet completed or failed.\n\n- Fulfilled: This state indicates that the asynchronous operation has completed successfully, and the promise has a resolved value.\n\n- Rejected: This state indicates that the asynchronous operation has failed, and the promise has a rejected value.\nThe state of a promise is determined by the resolve and reject functions passed to the Promise constructor. When the resolve function is called, the promise is set to the fulfilled state and the resolved value is stored in the promise. When the reject function is called, the promise is set to the rejected state and the rejected value is stored in the promise.\nOnce a promise has entered the fulfilled or rejected state, it cannot change its state. This is known as the “immutable” nature of promises.\nA promise is created using the Promise constructor, which takes a function as an argument. The function is passed two arguments: resolve and reject, which are functions that are used to signal the completion or failure of the asynchronous operation.\nHere is an example of using a promise:\nconst myPromise = new Promise((resolve, reject) => {\n  // Perform an asynchronous operation, such as a network request\n  setTimeout(() => {\n    // If the operation is successful, call the resolve function\n    resolve('Success');\n  }, 1000);\n});\n\n// Use the then() method to handle the promise's completion or failure\nmyPromise.then((result) => {\n  console.log(result); // Logs 'Success'\n}, (error) => {\n  console.error(error); // Not called\n});\nIn this example, a promise is created using the Promise constructor. The function passed to the constructor performs an asynchronous operation (a timeout in this case) and calls the resolve function if the operation is successful. The then() method is used to handle the promise’s completion or failure, and the result and error arguments passed to the then() function are the value returned by the resolve and reject functions, respectively.\n\n\n\nA promise object has three primary functions that can be used to handle the asynchronous operation that it represents:\n- then(): This function is used to handle the completion or failure of the promise. It takes two arguments: a success callback function and a failure callback function. The success callback function is called when the promise is fulfilled, and the failure callback function is called when the promise is rejected.\n\n- catch(): This function is used to handle the failure of the promise. It takes a single argument: a failure callback function that is called when the promise is rejected.\n\n- finally(): This function is called when the promise is settled (either fulfilled or rejected), regardless of the outcome of the asynchronous operation. It does not take any arguments.\nHere is an example of using the then(), catch(), and finally() functions with a promise:\nconst myPromise = new Promise((resolve, reject) => {\n  // Perform an asynchronous operation, such as a network request\n  setTimeout(() => {\n    // If the operation is successful, call the resolve function\n    resolve('Success');\n  }, 1000);\n});\n\n// Use the then() function to handle the promise's completion or failure\nmyPromise.then((result) => {\n  console.log(result); // Logs 'Success'\n}, (error) => {\n  console.error(error); // Not called\n});\n\n// Use the catch() function to handle the promise's failure\nmyPromise.catch((error) => {\n  console.error(error); // Not called\n});\n\n// Use the finally() function to handle the promise's settlement\nmyPromise.finally(() => {\n  console.log('Promise settled'); // Logs 'Promise settled'\n});\nIn this example, a promise is created using the Promise constructor and is eventually fulfilled with the value ‘Success’. The then() function is used to handle the promise’s fulfillment, and the catch() and finally() functions are used to handle the promise’s failure and settlement, respectively.\n\n\n\n\nPromise.race() method returns a promise that resolves or rejects as soon as one of the promises in an iterable resolves or rejects, with the value or reason from that promise.\nHere is an example of using Promise.race():\nconst promise1 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 500, 'one');\n});\n\nconst promise2 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'two');\n});\n\nPromise.race([promise1, promise2]).then(value => {\n  console.log(value);  // Output: \"two\"\n});\n\nIn this example, we have two promises that resolve with different values after different time intervals. We use Promise.race() to return a promise that resolves with the value of the first promise to resolve. In this case, promise2 resolves first, so the output is “two”.\n\n\n\n\nPromise.all() method returns a promise that resolves when all of the promises in an iterable have resolved, or rejects with the reason of the first passed promise that rejects.\nconst promise1 = Promise.resolve(3);\nconst promise2 = 42;\nconst promise3 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'foo');\n});\n\nPromise.all([promise1, promise2, promise3]).then(values => {\n  console.log(values);  // Output: [3, 42, \"foo\"]\n});\nIn this example, we have three promises: one that has already resolved, one that is a non-promise value, and one that will resolve after a delay. We use Promise.all() to return a promise that resolves with an array of the resolved values of the promises in the iterable. In this case, all of the promises have resolved, so the output is an array containing the resolved values of the promises.\nBoth Promise.race() and Promise.all() can be useful for handling multiple asynchronous operations and reacting to the resolution or rejection of those operations in a specific way.\n\n\n\n\nIn JavaScript, the async/await syntax is a way to write asynchronous code in a synchronous-like style. It allows developers to write asynchronous code that reads like synchronous code, making it easier to understand and reason about.\nThe async keyword is used to define an asynchronous function, and the await keyword is used to pause the execution of the function until a promise is fulfilled or rejected.\nHere is an example of using async/await to handle a promise:\nasync function getData() {\n  // Perform an asynchronous operation, such as a network request\n  const response = await fetch('https://example.com/data');\n\n  // If the operation is successful, return the response\n  return response.json();\n}\n\n// Use the getData() function\ngetData().then((data) => {\n  console.log(data); // Logs the data returned by the promise\n});\nIn this example, the getData() function is defined as an asynchronous function using the async keyword. The function uses the await keyword to pause its execution until the fetch() function returns a response. Once the response is returned, the function continues executing and returns the parsed JSON data.\nThe getData() function returns a promise, which can be handled using the then() function as shown. The then() function is called with the data returned by the promise as an argument.\nasync/await is a powerful and convenient way to write asynchronous code in JavaScript, and is often used in combination with other async/await features and technologies such as the fetch API and JavaScript libraries or frameworks.\n\n\n\n\n“Callback hell” is a term used to describe a situation where you have multiple nested callback functions in your code, which can make it difficult to read and understand. It can occur when you are using asynchronous code, such as when making HTTP requests, and need to wait for a response before taking further action.\nHere is an example of code that could be considered “callback hell”:\nfetch('http://example.com/api/data1', (error, response) => {\n  if (error) {\n    console.error(error);\n  } else {\n    fetch('http://example.com/api/data2', (error, response) => {\n      if (error) {\n        console.error(error);\n      } else {\n        fetch('http://example.com/api/data3', (error, response) => {\n          if (error) {\n            console.error(error);\n          } else {\n            // Do something with the data\n          }\n        });\n      }\n    });\n  }\n});\nIn this example, the code is making three sequential HTTP requests, and using callback functions to handle the responses. However, the code is difficult to read because of the many nested callback functions. It can be hard to see the overall structure and flow of the code, and it can be difficult to add new functionality or debug any issues that may arise.\nTo avoid “callback hell,” you can use techniques such as Promises, async/await, or async functions to write code that is easier to read and understand. These techniques allow you to write asynchronous code that looks and behaves more like synchronous code, which can make it easier to write, maintain, and debug your applications."
  },
  {
    "objectID": "creational.html",
    "href": "creational.html",
    "title": "Creational",
    "section": "",
    "text": "The builder pattern is a type of creational pattern that helps in building complex objects using simpler objects. It provides a flexible and step-by-step approach towards making these objects. It also keeps the representation and process of creation shielded.\nConsider the example of a restaurant that has to build a meal for its customers. The building process has various stages:\n\nThe customer comes in and places an orders for a meal to the cashier\nThe cashier forwards the order to the crew member (the builder) who makes the order\nThe builder assembles the meal consisting of the burger, fries, and soda of choice\nThe cashier receives the final meal from the builder\nThe customer receives the final order from the cashier\n\nEvery meal ordered by the customer regardless of the choices for the burger, fries, and soda will follow the same process. As you can see, a complex object is created following a step-by-step process.\nfunction Meal() {\n  this.make = function(builder){\n    builder.step1();\n    builder.step2();\n    builder.step3();\n    builder.step4();\n    return builder.get();\n  }\n}\nfunction MealBuilder(pattie,side,soda) {\n   this.meal = null;\n   this.step1 = function() {\n        this.meal = new Order();\n    };\n    this.step2 = function() {\n        this.meal.addBurger(pattie);\n    };\n    this.step3 = function(){\n      this.meal.addSide(side);\n    }\n    this.step4 = function(){\n      this.meal.addSoda(soda);\n    }\n    this.get = function() {\n        return this.meal;\n    };\n}\nfunction Order() {\n    this.burger = null;\n    this.side = null;\n    this.soda = null;\n    this.addBurger = function(pattie) {\n        this.burger = pattie;\n    };\n    this.addSide = function(side) {\n        this.side = side;\n    };\n    this.addSoda = function(soda){\n      this.soda = soda;\n    }\n    this.display = function(){\n      console.log(`You meal has a ${this.burger} burger, ${this.side} on the side, and a ${this.soda}.`)\n    }\n}\nvar meal = new Meal();\nvar mealBuilder = new MealBuilder(\"chicken\",\"curly fries\",\"coke\");\nvar chickenBurgerMeal = meal.make(mealBuilder);\nchickenBurgerMeal.display();\n\n\n\nYou can use this design pattern when building apps that require you to create complex objects. It can help you hide the construction process of building these objects.\nA good example would be a DOM, where you might need to create plenty of nodes and attributes. The construction process can get quite messy if you are building a complex DOM object. In cases like these, the builder pattern can be used.\n\n\n\nGamma categorization is a software design pattern that involves organizing code into categories based on their level of abstraction. The pattern is named after Erich Gamma, one of the authors of the book “Design Patterns: Elements of Reusable Object-Oriented Software”.\nThe idea behind gamma categorization is to group code into categories based on their level of abstraction, with the most abstract code at the top and the most concrete code at the bottom. This can make it easier to understand the structure of a codebase and navigate between different levels of abstraction.\nHere’s an example of how gamma categorization might be applied in JavaScript:\n// Most abstract\nclass Document {\n  constructor(text) {\n    this.text = text;\n  }\n  getText() {\n    return this.text;\n  }\n}\n// Less abstract\nclass DocumentViewer {\n  constructor(document) {\n    this.document = document;\n  }\n  display() {\n    console.log(this.document.getText());\n  }\n}\nclass DocumentEditor {\n  constructor(document) {\n    this.document = document;\n  }\n  edit(text) {\n    this.document.text = text;\n  }\n}\n// Most concrete\nclass FileDocument extends Document {\n  constructor(filePath) {\n    super();\n    this.filePath = filePath;\n  }\n  getText() {\n    // Read text from a file at the specified file path\n  }\n}\nclass WebDocument extends Document {\n  constructor(url) {\n    super();\n    this.url = url;\n  }\n  getText() {\n    // Read text from a web page at the specified URL\n  }\n}\nIn this example, the most abstract code is at the top (the Document class), followed by the less abstract code (the DocumentViewer and DocumentEditor classes), and finally the most concrete code (the FileDocument and WebDocument classes).\nThis organization makes it clear that the DocumentViewer and DocumentEditor classes depend on the abstract Document class, and that the FileDocument and WebDocument classes are concrete implementations of the Document class.\n\n\n\nThe builder design pattern is a software design pattern that separates the construction of a complex object from its representation, allowing you to construct the object step by step. This can be useful when you need to create an object that has a large number of possible configurations or when you want to separate the construction of an object from the code that uses it.\nHere’s an example of how the builder design pattern might be applied in JavaScript:\nclass User {\n  constructor(builder) {\n    this.name = builder.name;\n    this.email = builder.email;\n    this.age = builder.age;\n    this.phone = builder.phone;\n    this.address = builder.address;\n  }\n}\nclass UserBuilder {\n  constructor(name) {\n    this.name = name;\n  }\n  withEmail(email) {\n    this.email = email;\n    return this;\n  }\n  withAge(age) {\n    this.age = age;\n    return this;\n  }\n  withPhone(phone) {\n    this.phone = phone;\n    return this;\n  }\n  withAddress(address) {\n    this.address = address;\n    return this;\n  }\n  build() {\n    return new User(this);\n  }\n}\nconst user = new UserBuilder('John')\n  .withEmail('john@example.com')\n  .withAge(30)\n  .withPhone('123-456-7890')\n  .withAddress('123 Main St.')\n  .build();\nconsole.log(user);\n// Output: User { name: 'John', email: 'john@example.com', age: 30, phone: '123-456-7890', address: '123 Main St.' }\n\n\n\nIn the context of the builder design pattern in JavaScript, a “facet” is a property or feature of an object that can be constructed using the builder pattern. For example, in the previous examples, the User and Product classes had several facets (such as name, email, age, price, description, color, and size) that could be set using the UserBuilder and ProductBuilder classes, respectively.\nThe builder pattern allows you to construct an object with a large number of facets in a flexible and modular way. You can set each facet separately, and you can choose which facets to set and which to leave unset. This can be useful when you need to create an object with a large number of possible configurations.\nclass Product {\n  constructor(builder) {\n    this.name = builder.name;\n    this.price = builder.price;\n    this.description = builder.description;\n    this.color = builder.color;\n    this.size = builder.size;\n  }\n}\nclass ProductBuilder {\n  constructor(name) {\n    this.name = name;\n  }\n  withPrice(price) {\n    this.price = price;\n    return this;\n  }\n  withDescription(description) {\n    this.description = description;\n    return this;\n  }\n  withColor(color) {\n    this.color = color;\n    return this;\n  }\n  withSize(size) {\n    this.size = size;\n    return this;\n  }\n  build() {\n    return new Product(this);\n  }\n}\nconst product = new ProductBuilder('Shirt')\n  .withPrice(19.99)\n  .withDescription('A soft, comfortable shirt')\n  .withColor('blue')\n  .withSize('XL')\n  .build();\nconsole.log(product);\n// Output: Product { name: 'Shirt', price: 19.99, description: 'A soft, comfortable shirt', color: 'blue', size: 'XL' }"
  },
  {
    "objectID": "creational.html#when-to-use-the-factory-pattern",
    "href": "creational.html#when-to-use-the-factory-pattern",
    "title": "Creational",
    "section": "When to use the factory pattern?",
    "text": "When to use the factory pattern?\n\nWhen the type of objects required cannot be anticipated beforehand\nWhen multiple objects that share similar characteristics need to be created\nWhen you want to generalize the object instantiation process since the object set up is complex in nature"
  },
  {
    "objectID": "creational.html#factory",
    "href": "creational.html#factory",
    "title": "Creational",
    "section": "Factory",
    "text": "Factory\nA component responsible solely for the wholesale(not piecewise) creation of objects. The factory method design pattern is a software design pattern that defines an interface for creating an object, but lets subclasses decide which class to instantiate. The factory method pattern allows a class to defer instantiation to subclasses.\nclass Document {\n  constructor(text) {\n    this.text = text;\n  }\n  getText() {\n    return this.text;\n  }\n}\nclass DocumentFactory {\n  createDocument(type) {\n    if (type === 'txt') {\n      return new TxtDocument();\n    } else if (type === 'docx') {\n      return new DocxDocument();\n    } else {\n      throw new Error('Invalid document type');\n    }\n  }\n}\nclass TxtDocument extends Document {\n  constructor() {\n    super();\n  }\n  getText() {\n    // Read text from a .txt file\n  }\n}\nclass DocxDocument extends Document {\n  constructor() {\n    super();\n  }\n  getText() {\n    // Read text from a .docx file\n  }\n}\nconst factory = new DocumentFactory();\nconst txtDocument = factory.createDocument('txt');\nconsole.log(txtDocument.getText());\nconst docxDocument = factory.createDocument('docx');\nconsole.log(docxDocument.getText());"
  },
  {
    "objectID": "creational.html#abstract-factory",
    "href": "creational.html#abstract-factory",
    "title": "Creational",
    "section": "Abstract Factory",
    "text": "Abstract Factory\nThe abstract factory design pattern is a software design pattern that provides an interface for creating families of related or dependent objects without specifying their concrete classes.\nThe abstract factory pattern is similar to the factory method pattern, but it allows you to create families of objects rather than just individual objects. This can be useful when you need to create a group of related objects that have a common theme or that can work together in some way.\nclass Document {\n  constructor(text) {\n    this.text = text;\n  }\n  getText() {\n    return this.text;\n  }\n}\nclass DocumentFactory {\n  createDocument(type) {\n    if (type === 'txt') {\n      return new TxtDocument();\n    } else if (type === 'docx') {\n      return new DocxDocument();\n    } else {\n      throw new Error('Invalid document type');\n    }\n  }\n}\nclass TxtDocument extends Document {\n  constructor() {\n    super();\n  }\n  getText() {\n    // Read text from a .txt file\n  }\n}\nclass DocxDocument extends Document {\n  constructor() {\n    super();\n  }\n  getText() {\n    // Read text from a .docx file\n  }\n}\nclass DocumentEditor {\n  constructor(documentFactory) {\n    this.documentFactory = documentFactory;\n  }\n  openDocument(type) {\n    return this.documentFactory.createDocument(type);\n  }\n}\nconst factory = new DocumentFactory();\nconst editor = new DocumentEditor(factory);\nconst txtDocument = editor.openDocument('txt');\nconsole.log(txtDocument.getText());\nconst docxDocument = editor.openDocument('docx');\nconsole.log(docxDocument.getText());"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ModernJs",
    "section": "",
    "text": "A more concise function syntax, particularly useful for replacing short anonymous functions. The basic syntax for an arrow function is:\n(param1, param2) => {\n    clapHand(param1, param2);\n    return 'This worked';\n}\nHowever, if an arrow function only requires one line, then the curly braces and return keywords can be removed. Additionally, when these are used inline such as for a call to the array map function, the semicolon must be removed. Finally, if there is only one parameter, the parantheses around the parameter can also be removed. For example, this code will create and array with the values doubled:\n[1,2,3,4].map(num => num * 2);\nThere are few constratins to arrow functions which will be explored througouht the course. The most important of these is that arrow fucntions do not have their own  this  binding. Additionally,arrow functions cannot be used as a constructors or generators."
  },
  {
    "objectID": "index.html#destructuring-assignment",
    "href": "index.html#destructuring-assignment",
    "title": "ModernJs",
    "section": "Destructuring Assignment",
    "text": "Destructuring Assignment\n\nArray Destructuring\n\nconst [fist, second] = [1,2,3];\nconsole.log(first) // 1\nconsole.log(second) // 2\n\nWhen destructuring object it can also be renamed\n\nconst car = {\n    color: white,\n    model: Dodge,\n    vin: 123123123123,\n    engine: []\n}\n\nconst {color: dodgeColor, model: isDodge} = car\n\nconsole.log(dodgeColor) // white\nconsole.log(isDodge) // model\n\nDestructuring can also be used in a function parameter, for example\n\nfunction displayName({name}) {\n    console.log(name)\n}"
  },
  {
    "objectID": "index.html#rest-operator",
    "href": "index.html#rest-operator",
    "title": "ModernJs",
    "section": "Rest Operator",
    "text": "Rest Operator\nA javascript operator using … for condensing multiple elements into a single array. This uses the same synatx as the spread operator, but funtionality is essentially the opposite.\nRest syntax can be used in both arrays and objects to get all of the values not being destructured. For example:\n\nconst floffy = [\"Hey\", \"Floppy\", \"is\", \"my\", \"best friend\", \".\"]\nconst [firstWord, secondWord, ...rem] = floffy // ..rem is [\"is\", \"my\", \"best friend\", \".\"]\n\n// Rest on Object\n\nconst {key1, key2, ...rem} = car //  ...rem is {vin: value, engine:[]}"
  },
  {
    "objectID": "index.html#spread-operator",
    "href": "index.html#spread-operator",
    "title": "ModernJs",
    "section": "Spread Operator",
    "text": "Spread Operator\nIn JavaScript, the spread operator (…) is a syntax that allows you to expand an iterable object (such as an array or a string) into a list of its individual elements. It is often used in combination with other features such as destructuring and the rest/spread operator (…).\nHere is an example of how to use the spread operator:\nlet array1 = [1, 2, 3];\nlet array2 = [...array1, 4, 5];\n\nconsole.log(array2); // Output: [1, 2, 3, 4, 5]\nIn this example, the spread operator is used to expand the elements of the array1 into a list, which is then combined with the 4 and 5 elements to create a new array, array2.\nThe spread operator can also be used to spread the elements of an array into the arguments of a function, like this:\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nlet array = [1, 2, 3];\n\nconsole.log(sum(...array)); // Output: 6\nIn this example, the spread operator is used to spread the elements of the array into the arguments of the sum function, which adds them together and returns the result."
  },
  {
    "objectID": "index.html#template-literal",
    "href": "index.html#template-literal",
    "title": "ModernJs",
    "section": "Template Literal",
    "text": "Template Literal\nIn JavaScript, a template literal is a way to define a string that spans multiple lines and can contain expressions. Template literals are surrounded by backticks (`), rather than single or double quotes.\nHere is an example of a template literal that spans multiple lines and includes an expression:\nconst name = 'Bob';\nconst age = 30;\n\nconst message = `Hello, my name is ${name} and I am ${age} years old.`;\n// Output: \"Hello, my name is Bob and I am 30 years old.\"\nIn this example, the name and age variables are interpolated into the string using the ${} syntax. This is known as string interpolation.\nTemplate literals also allow you to define strings that span multiple lines, which can be useful for creating longer, more readable strings.\nconst html = `\n<div>\n  <h1>Hello, World!</h1>\n  <p>This is a paragraph</p>\n</div>\n`;\nTemplate literals were introduced in JavaScript as part of the ES6 (ECMAScript 6) specification. They provide a more powerful and flexible way to define strings compared to traditional string literals."
  },
  {
    "objectID": "index.html#null-coalescing",
    "href": "index.html#null-coalescing",
    "title": "ModernJs",
    "section": "Null Coalescing",
    "text": "Null Coalescing\nIn JavaScript, the null coalescing operator (??) is a logical operator that returns the first operand if it exists and is not null, or the second operand if the first operand is either null or undefined. It is a shorthand way of writing a conditional expression that checks for null or undefined.\nHere is an example of using the null coalescing operator:\nconst user = { name: 'Bob' };\n\nconst username = user.name ?? 'Guest';\n// Output: \"Bob\"\nIn this example, the username variable is assigned the value of user.name if it exists and is not null, or the string ‘Guest’ if user.name is either null or undefined.\nHere is the same example written using a conditional expression:\nconst username = user.name !== null && user.name !== undefined ? user.name : 'Guest';\nThe null coalescing operator can be useful when you want to provide a default value for a variable that might be null or undefined. It can also be used to simplify code by reducing the need for nested conditional expressions.\nThe null coalescing operator was introduced in JavaScript as part of the ES2020 (ECMAScript 2020) specification. It is supported in modern browsers and can be used with transpilers like Babel to support older browsers."
  },
  {
    "objectID": "index.html#optional-chaining",
    "href": "index.html#optional-chaining",
    "title": "ModernJs",
    "section": "Optional Chaining",
    "text": "Optional Chaining\nIn JavaScript, optional chaining is a feature that allows you to access an object’s properties, methods, or elements without having to check for null or undefined values. It is a shorthand way of writing a series of checks to see if an object, property, or element exists before trying to access it.\nHere is an example of using optional chaining to access an object’s property:\nconst user = { name: 'Bob' };\n\nconst username = user?.name;\n// Output: \"Bob\"\nIn this example, the username variable is assigned the value of user.name if user exists and is not null or undefined. If user is null or undefined, the value of username will be undefined.\nHere is the same example written without optional chaining:\nlet username;\nif (user && user.name) {\n  username = user.name;\n}\nOptional chaining can be useful when you want to access properties or elements of an object that may not exist, or when you are working with data that may be null or undefined. It can also help to simplify code by reducing the need for nested conditional statements.\nOptional chaining was introduced in JavaScript as part of the ES2020 (ECMAScript 2020) specification. It is supported in modern browsers and can be used with transpilers like Babel to support older browsers."
  },
  {
    "objectID": "index.html#short-circuit-evaulation",
    "href": "index.html#short-circuit-evaulation",
    "title": "ModernJs",
    "section": "Short Circuit Evaulation",
    "text": "Short Circuit Evaulation\nIn JavaScript, short-circuit evaluation is a feature that allows you to use logical operators (such as && and ||) to evaluate expressions and determine the value of a boolean expression. It is called “short-circuit” evaluation because the second operand is only evaluated if the first operand is not sufficient to determine the value of the expression.\nHere is an example of short-circuit evaluation using the && operator:\nconst user = { name: 'Bob' };\n\nconst username = user && user.name;\n// Output: \"Bob\"\nIn this example, the username variable is assigned the value of user.name if user exists and is not null or undefined. If user is null or undefined, the value of username will be undefined. This is because the && operator only evaluates the second operand (user.name) if the first operand (user) is truthy.\nHere is the same example written without short-circuit evaluation:\nlet username;\nif (user) {\n  username = user.name;\n}\nShort-circuit evaluation can be useful for reducing the number of conditional statements in your code, and for simplifying complex boolean expressions.\n\nNote that short-circuit evaluation is only possible with the && and || operators. It is not possible with the & and | operators, which always evaluate both operands regardless of the value of the first operand.\n\n|| operator only needs one expression to be true, if the left side is true then the right side will not be evaluated. This is quite the opposite of the && operator. For example,\ntrue || myFunc() // doesn't call myFunc\nfalse || myFunc() // calls myFunc"
  },
  {
    "objectID": "generator.html",
    "href": "generator.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "A generator is a special type of function that can be paused and resumed at any time, allowing you to execute code in a controlled, sequential manner. Generators are defined using the function* syntax, and can be used to create iterators or to implement asynchronous programming techniques.\nHere is an example to implement a async task queue\nfunction* runTasks(tasks) {\n  for (let task of tasks) {\n    yield executeTask(task);\n  }\n}\n\nfunction executeTask(task) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log(`Executing task: ${task}`);\n      resolve();\n    }, 1000);\n  });\n}\n\nconst tasks = ['Task 1', 'Task 2', 'Task 3'];\nconst taskRunner = runTasks(tasks);\n\nfunction runNextTask() {\n  let result = taskRunner.next();\n  if (!result.done) {\n    result.value.then(() => runNextTask());\n  }\n}\n\nrunNextTask();\n\nIn this example, the runTasks() generator function takes an array of tasks as an argument, and yields a promise for each task that is returned by the executeTask() function. The executeTask() function simulates the execution of a task by returning a promise that resolves after a 1 second delay.\nThe runNextTask() function uses the generator object returned by the runTasks() generator function to execute the tasks in sequence. It calls the next() method on the generator object to retrieve the next task, and waits for the task’s promise to resolve before calling itself again to execute the next task. This process continues until all tasks have been executed, or until the generator function has completed.\nGenerators can be a useful tool for creating asynchronous programs that are easy to understand and maintain. They can help you write code that is more modular and reusable, and can make it easier to manage the flow of data in your programs.\nMore Examples\nfunction* greetStudents(students) {\n  for (let student of students) {\n    yield `Hello, ${student.name}! You are enrolled in CSE 341.`;\n    yield `Your assignment for this week is ${student.assignment}.`;\n  }\n}\n\nconst students = [\n  { name: 'John', assignment: 'Homework 1' },\n  { name: 'Mary', assignment: 'Homework 2' },\n  { name: 'Alice', assignment: 'Homework 3' },\n  { name: 'Bob', assignment: 'Homework 4' }\n];\n\nconst studentGreeting = greetStudents(students);\n\nconsole.log(studentGreeting.next().value); // Output: \"Hello, John! You are enrolled in CSE 341.\"\nconsole.log(studentGreeting.next().value); // Output: \"Your assignment for this week is Homework 1.\"\nconsole.log(studentGreeting.next().value); // Output: \"Hello, Mary! You are enrolled in CSE 341.\"\nconsole.log(studentGreeting.next().value); // Output: \"Your assignment for this week is Homework 2.\"\nconsole.log(studentGreeting.next().value); // Output: \"Hello, Alice! You are enrolled in CSE 341.\"\nconsole.log(studentGreeting.next().value\n\n\n\nAn iterator is an object that allows you to access and iterate over the elements of a collection, such as an array or an object. An iterator has a next() method that returns the next element in the collection, along with a done property that indicates whether the iterator has reached the end of the collection.\nIterators are typically used with the for-of loop, which automatically calls the next() method on the iterator and terminates the loop when the done property is true.\nHere is an example of using an iterator to iterate over the elements of an array:\nconst fruits = ['apple', 'banana', 'mango'];\n\nconst fruitIterator = fruits[Symbol.iterator]();\nconsole.log(fruitIterator.next()); // Output: { value: \"apple\", done: false }\nconsole.log(fruitIterator.next()); // Output: { value: \"banana\", done: false }\nconsole.log(fruitIterator.next()); // Output: { value: \"mango\", done: false }\nconsole.log(fruitIterator.next()); // Output: { value: undefined, done: true }\n\nIn this example, the fruits array has a built-in iterator that can be accessed using the Symbol.iterator symbol. The iterator’s next() method returns an object with a value property that holds the current element in the array, and a done property that indicates whether the iterator has reached the end of the array.\nYou can also create your own iterators"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "network.html",
    "href": "network.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "HTTP (Hypertext Transfer Protocol) is a protocol used to send and receive data over the internet. It is the foundation of the World Wide Web, and is used by web browsers and servers to communicate with each other.\nIn JavaScript, you can use the XMLHttpRequest object or the fetch() function to make HTTP requests to a server. These requests can be used to retrieve data from a server, or to send data to a server for processing.\nTo make an HTTP request in JavaScript, you first create an instance of XMLHttpRequest or call fetch(), and then specify the type of request you want to make (e.g. GET, POST, PUT, DELETE) and the URL of the server you want to send the request to. You can also specify additional options, such as the data you want to send with the request or the headers you want to include.\nOnce the request has been sent, the server will process it and send back a response. In JavaScript, you can use event listeners or Promises to handle the response and take appropriate action based on the data received.\nFor example, you might use an HTTP request to retrieve a list of products from an e-commerce API, or to send a form submission to a server for processing. HTTP requests are a key part of modern web development, and are used in many different types of applications.\n\n\n\nThe fetch() function in JavaScript is a modern, Promise-based API for making HTTP requests. It provides a simple and flexible way to retrieve data from a server, and is supported in all modern browsers.\nWhen you call fetch(), you can pass a number of options to customize the request. These options are specified as an object in the second argument to fetch(). Some of the options you can specify include:\n- method: The HTTP method to use for the request (e.g. GET, POST, PUT, DELETE).\n- headers: An object containing headers to send with the request.\n- body: The body of the request. This can be a string, a Blob, a FormData object, or any other object that can be used as the body of an HTTP request.\n- mode: The mode to use for the request (e.g. \"cors\", \"no-cors\", \"same-origin\").\n- cache: The cache mode to use for the request (e.g. \"default\", \"no-cache\", \"reload\", \"force-cache\", \"only-if-cached\").\n- credentials: The credentials mode to use for the request (e.g. \"omit\", \"same-origin\", \"include\").\n- redirect: The redirect mode to use for the request (e.g. \"follow\", \"error\", \"manual\").\nHere’s an example of how to use the fetch() function with some of these options:\n\nfetch('http://example.com/api/data', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    name: 'John',\n    age: 30\n  }),\n  mode: 'cors',\n  cache: 'no-cache',\n  credentials: 'include',\n  redirect: 'follow'\n})\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error(error));\nThis example makes a POST request to the /api/data endpoint, with a JSON-formatted body and the specified headers and options. The response is then parsed as JSON and logged to the console.\n\n\n\n\nXMLHttpRequest is a built-in object in JavaScript that allows you to send HTTP requests to a server and receive responses. It is a fundamental part of the web, and is used by web browsers and servers to communicate with each other.\nTo use XMLHttpRequest, you first create an instance of the object, and then call its open() method to specify the type of request you want to make (e.g. GET, POST, PUT, DELETE) and the URL of the server you want to send the request to. You can also specify additional options, such as the data you want to send with the request or the headers you want to include.\nOnce the request has been opened, you can call the send() method to actually send the request to the server. The server will then process the request and send back a response, which you can handle using event listeners or callback functions.\nHere’s an example of how to use XMLHttpRequest to send a GET request and log the response:\nconst request = new XMLHttpRequest();\nrequest.open('GET', 'http://example.com/api/data');\nrequest.onload = () => {\n  console.log(request.response);\n};\nrequest.send();\nThis example creates a new XMLHttpRequest object, opens a GET request to the /api/data endpoint, and sets an onload event listener to log the response to the console. When the send() method is called, the request is sent to the server, and the response is logged when it is received.\nXMLHttpRequest is a powerful and flexible API, and is widely used in modern web development. It is supported in all modern browsers.\n\n\n\n\nasync function getData() {\n  try {\n    const response = await fetch('http://example.com/api/data');\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\ngetData();\nIn this example, the getData() function is defined as async, which means it returns a Promise that is resolved when the function is complete. The await keyword is used to wait for the Promise returned by fetch() to resolve, and the try and catch blocks are used to handle any errors that may occur.\nThe fetch() function is called with the URL of the server to send the request to, and the response is passed to the response.json() function to parse the response as JSON. The resulting data is then logged to the console.\nIf an error occurs at any point (e.g. if the server returns a 404 error or the response cannot be parsed as JSON), it will be caught in the catch block and logged to the console.\nUsing async and await can make it easier to write asynchronous code that is easier to read and understand, as it allows you to write code that looks and behaves more like synchronous code."
  },
  {
    "objectID": "dom.html",
    "href": "dom.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "DOM Manipulation\nDOM manipulation refers to the process of modifying the structure, content, or style of an HTML or XML document using a programming language, typically JavaScript. The Document Object Model (DOM) is a programming interface for HTML and XML documents that represents the structure of a document as a tree of objects, with each object representing an element in the document.\nHere are some examples of DOM manipulation using JavaScript:\n- Adding, deleting, or modifying elements in the document\n- Changing the text or attribute values of elements\n- Changing the styles of elements using CSS\n- Handling events such as clicks, hover, or form submissions\nDOM manipulation is an important part of web development, as it allows you to dynamically update the content and layout of a webpage based on user input or other events. It is typically used in combination with other technologies such as HTML, CSS, and JavaScript libraries or frameworks to create interactive and responsive websites and applications.\nThere are a lot of functions and properties realted to dom manipulation,but these are some of the more common ones.\n\nGetting Elements\n\ndocument.getElementById(id): Gets a single element based on its attribute\n\n<!-- HTML document -->\n<p id=\"my-paragraph\">Hello, World!</p>\n\n<script>\n  \n  const paragraph = document.getElementById('my-paragraph');\n\n  // Output the text of the element\n  console.log(paragraph.innerText); // Output: \"Hello, World!\"\n</script>\n\n\ndocument.querySelector(selector): Gets a single element based on a selector. If multiple elements match the selector, return the first one.\n\n<!-- HTML document -->\n<p>Hello, World!</p>\n<p>Hello, DOM!</p>\n\n<script>\n  // Select the first `p` element\n  const paragraph = document.querySelector('p');\n\n  // Output the text of the element\n  console.log(paragraph.innerText); // Output: \"Hello, World!\"\n</script>\n\n\ndocument.querySelectorAll(selector): Gets all elements matching a selector as a NodeList\n\n<!-- HTML document -->\n<p>Hello, World!</p>\n<p>Hello, DOM!</p>\n\n<script>\n  // Select all `p` elements\n  const paragraphs = document.querySelectorAll('p');\n\n  // Output the text of the elements\n  paragraphs.forEach(paragraph => console.log(paragraph.innerText));\n  // Output: \"Hello, World!\", \"Hello, DOM!\"\n</script>\n \n\ndocument.getElementsByTagName(tagName): Gets all elements with a specific tag as an HTML Collection.\n\n<!-- HTML document -->\n<p>Hello, World!</p>\n<p>Hello, DOM!</p>\n\n<script>\n  // Select all `p` elements\n  const paragraphs = document.getElementsByTagName('p');\n\n  // Output the text of the elements\n  for (let i = 0; i < paragraphs.length; i++) {\n    console.log(paragraphs[i].innerText);\n  }\n  // Output: \"Hello, World!\", \"Hello, DOM!\"\n</script>\n\n\ndocument.getElementsByClassName(className): Gets all elements with a specific class as an HTML collection.\n\n<!-- HTML document -->\n<p class=\"error\">An error occurred</p>\n<div class=\"error\">Something went wrong</div>\n\n<script>\n  // Select all elements with the \"error\" class\n  const errors = document.getElementsByClassName('error');\n\n  // Output the text of the elements\n  for (let i = 0; i < errors.length; i++) {\n    console.log(errors[i].innerText);\n  }\n  // Output: \"An error occurred\", \"Something went wrong\"\n</script>\n\n\nSetting Attributes\n\nelement.setAttribute(‘attribute’, ‘value’): Sets an HTML attribute to a specific value\n\n<!-- HTML document -->\n<a id=\"my-link\">Click here</a>\n\n<script>\n  // Retrieve the element\n  const link = document.getElementById('my-link');\n\n  // Set the `href` attribute\n  link.setAttribute('href', 'https://www.example.com');\n</script>\n\n\nelement.textContent: Used to get a text content of an element.\n\n<!-- HTML document -->\n<p>Hello, <strong>World</strong>!</p>\n\n<script>\n  // Retrieve the element\n  const paragraph = document.querySelector('p');\n\n  // Get the text content of the element\n  const text = paragraph.textContent;\n\n  // Output the text content\n  console.log(text); // Output: \"Hello, World!\"\n</script>\n\nelement.getAttribute: used to get or set the value of an attribute on an element. It takes the name of the attribute as an argument, and returns the value of the attribute if it exists, or null if it does not.\n\n<!-- HTML document -->\n<a id=\"my-link\" href=\"https://www.example.com\">Click here</a>\n\n<script>\n  // Retrieve the element\n  const link = document.getElementById('my-link');\n\n  // Get the value of the `href` attribute\n  const href = link.getAttribute('href');\n\n  // Output the value of the attribute\n  console.log(href); // Output: \"https://www.example.com\"\n</script>\n\nelement.classList: used to manipulate the element’s class names. It is a DOMTokenList object that provides methods for adding, removing, and checking for the presence of class names on an element.\n\n<!-- HTML document -->\n<div id=\"my-div\">This is a div</div>\n\n<script>\n  // Retrieve the element\n  const div = document.getElementById('my-div');\n\n  // Add the \"error\" class to the element\n  div.classList.add('error');\n</script>\n\n\n\nAdding and Removing Elements\n\ndocument.createElement(tagName): Creates a new HTML element. It takes the tag name of the element to be created as an argument, and returns a new element with that tag name.\n\n<!-- HTML document -->\n<div id=\"my-div\"></div>\n\n<script>\n  // Create a new `p` element\n  const paragraph = document.createElement('p');\n\n  // Set the text content of the element\n  paragraph.textContent = 'Hello, World!';\n\n  // Append the element to the document\n  document.getElementById('my-div').appendChild(paragraph);\n</script>\n\n// Result \n\n<div id=\"my-div\">\n  <p>Hello, World!</p>\n</div>\n\n\ndocument.createTextNode(text): Creates a text node as an alternative to settting textContent. It takes a string of text as an argument, and returns a new text node with that text.\n\n<!-- HTML document -->\n<div id=\"my-div\"></div>\n\n<script>\n  // Create a new text node\n  const textNode = document.createTextNode('Hello, World!');\n\n  // Append the text node to the document\n  document.getElementById('my-div').appendChild(textNode);\n</script>\n\n// Result \n\n\n<div id=\"my-div\">Hello, World!</div>\n\n\ndocument.createDocumentFragment(): A document fragment is a lightweight, in-memory representation of a part of a document. It can be used to build up a document structure in memory, and then insert the entire structure into the document at once, rather than inserting each element individually. This can be more efficient and performant than repeatedly inserting elements into the document one at a time.\n\n<!-- HTML document -->\n<div id=\"my-div\"></div>\n\n<script>\n  // Create a new document fragment\n  const fragment = document.createDocumentFragment();\n\n  // Create some elements and text nodes\n  const h1 = document.createElement('h1');\n  h1.textContent = 'Hello, World!';\n  const p = document.createElement('p');\n  p.textContent = 'This is a paragraph.';\n  const textNode = document.createTextNode('And this is some text.');\n\n  // Append the elements and text nodes to the fragment\n  fragment.appendChild(h1);\n  fragment.appendChild(p);\n  fragment.appendChild(textNode);\n\n  // Append the fragment to the document\n  document.getElementById('my-div').appendChild(fragment);\n\n</script>\n\nelement.appendChild(element): Appends an element to the end of the contents of another element\n\n<!-- HTML document -->\n<div id=\"my-div\">\n  <p>This is a paragraph.</p>\n</div>\n\n<script>\n  // Retrieve the element\n  const div = document.getElementById('my-div');\n\n  // Create a new element\n  const h1 = document.createElement('h1');\n  h1.textContent = 'Hello, World!';\n\n  // Append the element to the end of the div\n  div.append(h1);\n</script>\n\n// Result \n<div id=\"my-div\">\n  <p>This is a paragraph.</p>\n  <h1>Hello, World!</h1>\n</div>\n\n\nelement.prepend(node1): Prepends an element to the beginning of the contents of another element\n\n<!-- HTML document -->\n<div id=\"my-div\">\n  <p>This is a paragraph.</p>\n</div>\n\n<script>\n  // Retrieve the element\n  const div = document.getElementById('my-div');\n\n  // Create a new element\n  const h1 = document.createElement('h1');\n  h1.textContent = 'Hello, World!';\n\n  // Prepend the element to the beginning of the div\n  div.prepend(h1);\n</script>\n\n//  Result \n<div id=\"my-div\">\n  <h1>Hello, World!</h1>\n  <p>This is a paragraph.</p>\n</div>\n\nelement.remove(): Removes the element from the DOM\n\n<!-- HTML document -->\n<div id=\"my-div\">\n  <p>This is a paragraph.</p>\n  <button id=\"remove-button\">Remove</button>\n</div>\n\n<script>\n  // Retrieve the button element\n  const button = document.getElementById('remove-button');\n\n  // Add an event listener to the button\n  button.addEventListener('click', () => {\n    // Retrieve the element to be removed\n    const p = document.querySelector('p');\n\n    // Remove the element\n    p.remove();\n  });\n</script>\n\n\n\nSize and Scrolling\n\nwindow.getComputedStyle(element): a function of the window object in JavaScript that is used to get the computed values of an element’s style properties. It takes an element and an optional pseudo-element as arguments, and returns a CSSStyleDeclaration object that contains the computed values of the element’s style properties.\n\n<!-- HTML document -->\n<style>\n  #my-div {\n    background-color: red;\n    width: 200px;\n    height: 100px;\n  }\n</style>\n<div id=\"my-div\">This is a div</div>\n\n<script>\n  // Retrieve the element\n  const div = document.getElementById('my-div');\n\n  // Get the computed style of the element\n  const style = window.getComputedStyle(div);\n\n  // Output the values of the style properties\n  console.log(style.backgroundColor); // Output: \"rgb(255, 0, 0)\"\n  console.log(style.width); // Output: \"200px\"\n  console.log(style.height); // Output: \"100px\"\n</script>\n\n\nelement.clientHeight: used to get the height of an element, including its padding but not its margins, borders, or scrollbars. It is a read-only property and is measured in pixels.\n\n<!-- HTML document -->\n<style>\n  #my-div {\n    background-color: red;\n    width: 200px;\n    height: 100px;\n    padding: 20px;\n  }\n</style>\n<div id=\"my-div\">This is a div</div>\n\n<script>\n  // Retrieve the element\n  const div = document.getElementById('my-div');\n\n  // Get the client height of the element\n  const height = div.clientHeight;\n\n  // Output the client height\n  console.log(height); // Output: 140 (200px height + 20px padding on top + 20px padding on bottom)\n</script>\n\nelement.offsetHeight: used to get the height of an element, including its padding, borders, and scrollbars, but not its margins. It is a read-only property and is measured in pixels.\n\n<!-- HTML document -->\n<style>\n  #my-div {\n    background-color: red;\n    width: 200px;\n    height: 100px;\n    padding: 20px;\n    border: 2px solid black;\n  }\n</style>\n<div id=\"my-div\">This is a div</div>\n\n<script>\n  // Retrieve the element\n  const div = document.getElementById('my-div');\n\n  // Get the offset height of the element\n  const height = div.offsetHeight;\n\n  // Output the offset height\n  console.log(height); // Output: 144 (100px height + 20px padding on top + 20px padding on bottom + 2px border on top + 2px border on bottom)\n</script>\n\nelement.scrollHeight: used to get the total height of an element’s content, including its padding, but not its margins, borders, or scrollbars. It is a read-only property and is measured in pixels.\n\n<!-- HTML document -->\n<style>\n  #my-div {\n    background-color: red;\n    width: 200px;\n    height: 100px;\n    padding: 20px;\n    overflow: scroll;\n  }\n</style>\n<div id=\"my-div\">\n  <p>This is a paragraph.</p>\n  <p>This is another paragraph.</p>\n</div>\n\n<script>\n  // Retrieve the element\n  const div = document.getElementById('my-div');\n\n  // Get the scroll height of the element\n  const height = div.scrollHeight;\n\n  // Output the scroll height\n  console.log(height); // Output: 128 (20px padding on top + 20px padding on bottom + 48px height of first paragraph + 48px height of second paragraph)\n</script>\nIn this example, the div element is retrieved from the document using document.getElementById(), and the scrollHeight property is used to get the total height of the element’s content. The scrollHeight includes the element’s top and bottom padding of 20px and the combined height of the two p elements, which is 48px each, for a total of 96px. The output is the value 128, which represents the total height of the element’s content.\nThe element.scrollHeight property is useful for getting the total height of an element’s content when the element has scrollbars, or for determining if an element’s content overflows its boundaries. It can be used in combination with other size properties, such as element.clientHeight, element.offsetHeight, and element.scrollTop, to manipulate the scroll position of an element.\n\nelement.offsetTop: used to get the distance of the element from the top of the offset parent element. The offset parent is the nearest ancestor element that has a position other than static. The offsetTop property is a read-only property and is measured in pixels.\n\n<!-- HTML document -->\n<style>\n  #my-div {\n    background-color: red;\n    width: 200px;\n    height: 100px;\n    position: relative;\n    top: 50px;\n  }\n</style>\n<div id=\"my-parent\">\n  <div id=\"my-div\">This is a div</div>\n</div>\n\n<script>\n  // Retrieve the element\n  const div = document.getElementById('my-div');\n\n  // Get the offset top of the element\n  const top = div.offsetTop;\n\n  // Output the offset top\n  console.log(top); // Output: 50 (distance from top of parent element)\n</script>\n\n\n\nelement.scrollIntoView(): used to scroll the element into view within its nearest scrollable ancestor. It takes an optional argument that specifies how the element should be aligned within the viewport.\n\n<!-- HTML document -->\n<style>\n  #my-div {\n    background-color: red;\n    width: 200px;\n    height: 100px;\n  }\n  #my-parent {\n    overflow: scroll;\n    height: 200px;\n  }\n</style>\n<div id=\"my-parent\">\n  <div id=\"my-div\">This is a div</div>\n</div>\n\n<script>\n  // Retrieve the element\n  const div = document.getElementById('my-div');\n\n  // Scroll the element into view\n  div.scrollIntoView();\n</script>\n\n\nelement.scrollTo(): used to scroll the document to a specified position. It takes two arguments: the x-coordinate and the y-coordinate of the position to scroll to. The coordinates are measured in pixels and are relative to the top-left corner of the document.\n\n<!-- HTML document -->\n<style>\n  #my-div {\n    background-color: red;\n    width: 200px;\n    height: 100px;\n  }\n</style>\n<div id=\"my-div\">This is a div</div>\n\n<script>\n  // Scroll the document to the top-left corner\n  window.scrollTo(0, 0);\n\n  // Scroll the document to the position of the div element\n  const div = document.getElementById('my-div');\n  window.scrollTo(div.offsetLeft, div.offsetTop);\n</script>"
  },
  {
    "objectID": "basic.html",
    "href": "basic.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "The primary programming language of the web, primarily used for adding functionality to websites. JavaScript is a general purpose multi-paradigm programming language with dynamic typing.\nLearn more: https://developer.mozilla.org/en-US/docs/Web/JavaScript\n\n\n\n\nA style of programming. Oftentimes languages are built with a specific paradigm in mind, but JavaScript is known as a multi-paradigm language, because it allows for programming in a variety of paradigms. Some of the major paradigms of JavaScript include:\n\n\n\nEvent-driven: Functions can be made to respond to events, such as when a user clicks on an element or scrolls down the page.\n\n\nFunctional: Functions can be written as “pure functions”, meaning functions that always have the same output for a given set of arguments and never produce side effects. Additionally, JavaScript supports first-class functions and higher-order functions. This means that functions can be treated as normal values, passed as arguments to other functions and returned from functions.\n\n\nObject-oriented: Objects can be created as custom data stores and they can be made to inherit from each other.\n\n\nImperative: Programs can be written by explicitly describing the control flow, such as with loops and conditionals.\n\n\nDeclarative: Programs can be written by describing the desired output with implicit control flow. Oftentimes this is associated with functional programming (e.g. using the forEach function to loop over an array instead of a for loop).\n\n\n\n\n\n\nThe most basic data types of a language. In JavaScript, there are 7 primitive types:\n\n\n\nNumber: Numeric values, including integers and decimal values.\n\n\nBigInt: Integers too large to store in a number.\n\n\nBoolean: A binary value of true or false.\n\n\nString: A sequence of characters.\n\n\nSymbol: A dynamically generated unique value.\n\n\nNull: A nonexistent value.\n\n\nUndefined: A value that has not been set.\n\n\n\nJavaScript has a typeof operator that can get the type of a value as a lowercase string. However, do be aware that this function does have some special casing. For example, typeof function will return “function” even though functions are just objects.\n\nLearn more: https://developer.mozilla.org/en-US/docs/Glossary/Primitive"
  },
  {
    "objectID": "module.html",
    "href": "module.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "A module is a self-contained piece of code that exports a specific set of features or values, and can be imported and used by other modules. Modules allow you to organize your code into reusable chunks and can help you to better manage the dependencies and interactions between different parts of your application.\nThere are several ways to create and use modules in JavaScript. One common approach is to use the export and import statements, which are part of the ECMAScript (ES) module system.\nHere is an example of exporting a value from a module:\n// math.js\n\nexport const PI = 3.14;\n\nexport function calculateCircumference(radius) {\n  return 2 * PI * radius;\n}\nIn this example, the math.js module exports the PI constant and the calculateCircumference() function, which can be imported and used by other modules.\nHere is an example of importing a value from a module:\n// main.js\n\nimport { PI, calculateCircumference } from './math';\n\nconsole.log(PI); // Output: 3.14\nconsole.log(calculateCircumference(5)); // Output: 31.4\nIn this example, the main.js module imports the PI constant and the calculateCircumference() function from the math module, and uses them to perform some calculations.\nYou can also use the export default statement to specify a default export for a module, which can be imported using the import statement without the curly braces. For example:\n// math.js\n\nexport default function add(x, y) {\n  return x + y;\n}\n// main.js\n\nimport add from './math';\n\nconsole.log(add(2, 3)); // Output: 5\nIn this example, the math.js module exports a default function that can be imported and used by the main.js module without the need to specify a named export.\nModules can help you to organize and modularize your code, and can make it easier to manage dependencies and interactions between different parts of your application. They can also help you to create reusable components that can be shared and imported by multiple modules, making it easier to build and maintain complex applications.\n\n\n\nIn JavaScript, an immediately-invoked function expression (IIFE) is a function that is defined and immediately executed, without being stored in a variable or assigned to a property. IIFEs are often used to create private scopes, to hide variables and functions from the global scope, and to prevent name collisions with other variables and functions.\nAn IIFE is defined using the function expression syntax, followed by parentheses and a pair of curly braces. The function is invoked by adding a pair of parentheses after the function definition.\n(function() {\n  let secret = '123456';\n\n  function getSecret() {\n    return secret;\n  }\n\n  function setSecret(newSecret) {\n    secret = newSecret;\n  }\n\n  window.secretModule = {\n    getSecret: getSecret,\n    setSecret: setSecret\n  };\n})();\n\nconsole.log(secretModule.getSecret()); // Output: \"123456\"\nsecretModule.setSecret('abcdef');\nconsole.log(secretModule.getSecret()); // Output: \"abcdef\"\n\nIn this example, the IIFE creates a private scope and defines the secret variable and the getSecret() and setSecret() functions. It then exports these functions to the global scope by assigning them to the secretModule object, which can be accessed by other parts of the application.\nThe secret variable is not accessible from the global scope, and cannot be modified directly. Instead, it can only be accessed and modified using the getSecret() and setSecret() functions, which are exported by the IIFE. This allows you to create a secure, private scope for storing sensitive data, and to control access to that data using well-defined interfaces.\nIIFEs can be a useful tool for organizing and modularizing your code, and for creating private scopes that can help you to manage dependencies and interactions between different parts of your application. They can also help you to prevent name collisions and to keep"
  },
  {
    "objectID": "worker.html",
    "href": "worker.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "Web-Worker\na web worker is a background thread that runs concurrently with the main thread of your web application, allowing you to perform long-running tasks or computations without blocking the UI or other parts of the application. Web workers are particularly useful for tasks that are computationally intensive or that involve network communication, as they can help to improve the performance and responsiveness of your application.\nWeb workers are created using the Worker constructor, which takes the URL of a JavaScript file as an argument. The worker file must contain the code that the worker will execute.\nHere is an example of creating and using a web worker:\nconst worker = new Worker('worker.js');\n\nworker.onmessage = function(event) {\n  console.log(`Received message from worker: ${event.data}`);\n}\n\nworker.postMessage('Hello, worker!');\nIn this example, the worker.js file contains the code that the worker will execute. The main thread creates a new worker using the Worker constructor and specifies the URL of the worker file. It then registers an event handler for the message event, which is fired when the worker sends a message back to the main thread.\nThe main thread can communicate with the worker using the postMessage() method, which sends a message to the worker. The worker can respond by sending a message back to the main thread using the postMessage() method on the self object.\nHere is an example of the code in the worker file:\nself.onmessage = function(event) {\n  console.log(`Received message from main thread: ${event.data"
  },
  {
    "objectID": "Object.html",
    "href": "Object.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "Objects are core data structure in javascript. Particularly, it is an unorded collection of key-value pairs. You can use objects to store data, ogranize code, and represent real-world entities. It is crucial to retain that Object are reference values\nIn javascript, values can be either primite values or reference values:\nReference values, are complex data types that represent a reference to a value, rather than the value itself. The referenve values in JavaScript are:\n- Objects (arrays, function, and classes)\n- Maps \n- Sets \n- WeakMaps \n- WeakSets \nHere is an example of an object in JavaScript:\nlet object = {\n  key1: 'value1',\n  key2: 'value2',\n  key3: 'value3'\n};\n\nIn this example, the object has three properties: key1, key2, and key3. Each property has a corresponding value, which can be a primitive data type (such as a string or number), or a more complex data type (such as an array or another object).\nYou can access the properties of an object using dot notation or bracket notation, like this:\nconsole.log(object.key1); // Output: 'value1'\nconsole.log(object['key2']); // Output: 'value2'\nYou can also add, remove, or modify the properties of an object using dot notation or bracket notation, like this:\nobject.key4 = 'value4';\ndelete object.key3;\nobject['key2'] = 'new value';\nObjects are often used to store data in the form of key-value pairs. For example, you might use an object to represent a person, like this:\nlet person = {\n  name: 'John',\n  age: 10,\n  occupation: 'developer'\n};\nYou can also use objects to store functions, which are known as methods. For example:\nlet calculator = {\n  add: function(x, y) {\n    return x + y;\n  },\n  subtract: function(x, y) {\n    return x - y;\n  }\n};\n\nconsole.log(calculator.add(1, 2)); // Output: 3\nconsole.log(calculator.subtract(5, 3)); // Output: 2\n\nObjects are fundamental part of javascript and are used extensively in modern JavaScript Programming.\n\n\n\nThe spread operator (…) in JavaScript can be used with objects to create a new object that combines the properties of the original object with additional properties or values. This is often referred to as object spreading or object rest/spread syntax.\nHere is an example of how to use the spread operator with an object:\nlet object1 = {\n  key1: 'value1',\n  key2: 'value2'\n};\n\nlet object2 = {\n  key3: 'value3',\n  ...object1\n};\n\nconsole.log(object2);\n// Output: {key3: \"value3\", key1: \"value1\", key2: \"value2\"}\nIn this example, the object2 is created by spreading the properties of object1 into a new object. The result is an object that contains the properties of both object1 and object2.\nYou can also use the spread operator to override properties of the original object, like this:\nlet object1 = {\n  key1: 'value1',\n  key2: 'value2'\n};\n\nlet object2 = {\n  ...object1,\n  key1: 'new value'\n};\n\nconsole.log(object2);\n// Output: {key1: \"new value\", key2: \"value2\"}\nIn this example, the key1 property of object1 is overridden by the key1 property of object2.\nYou can also use the spread operator to merge multiple objects into a single object, like this:\nlet object1 = {\n  key1: 'value1'\n};\n\nlet object2 = {\n  key2: 'value2'\n};\n\nlet object3 = {\n  key3: 'value3'\n};\n\nlet mergedObject = {\n  ...object1,\n  ...object2,\n  ...object3\n};\n\nconsole.log(mergedObject);\n// Output: {key1: \"value1\", key2: \"value2\", key3: \"value3\"}\n\n\n\n\nObject.assign() is a method in JavaScript that is used to copy the values of all enumerable own properties from one or more source objects to a target object. It returns the target object.\nHere are some examples of how to use Object.assign():\nlet object1 = {\n  key1: 'value1',\n  key2: 'value2'\n};\n\nlet object2 = {\n  key3: 'value3'\n};\n\nlet targetObject = Object.assign({}, object1, object2);\n\nconsole.log(targetObject);\n// Output: {key1: \"value1\", key2: \"value2\", key3: \"value3\"}\n\nExample 2. \n\nlet object1 = {\n  key1: 'value1'\n};\n\nlet object2 = {\n  key2: 'value2'\n};\n\nlet object3 = {\n  key3: 'value3'\n};\n\nlet mergedObject = Object.assign({}, object1, object2, object3);\n\nconsole.log(mergedObject);\n// Output: {key1: \"value1\", key2: \"value2\", key3: \"value3\"}\n\n\nIt is a useful method for copying and merging objects in JavaScript, and it is often used in combination with other features such as destructuring and the rest/spread operator (…).\n\n\n\n\nObject destructuring is a syntax in JavaScript that allows you to extract properties from an object and assign them to variables. It is a convenient way to extract data from objects and can be used in combination with other features such as the spread operator (…) and the rest/spread operator (…).\nHere is an example of object destructuring:\nlet object = {\n  key1: 'value1',\n  key2: 'value2',\n  key3: 'value3'\n};\n\nlet {key1, key2} = object;\n\nconsole.log(key1); // Output: 'value1'\nconsole.log(key2); // Output: 'value2'\nYou can also use object destructuring to assign the extracted properties to variables with different names, like this:\nlet {key1: newKey1, key2: newKey2} = object;\n\nconsole.log(newKey1); // Output: 'value1'\nconsole.log(newKey2); // Output: 'value2'\nYou can also use object destructuring in combination with the spread operator (…) to extract some properties and spread the rest into a new object, like this:\nlet {key1, ...rest} = object;\n\nconsole.log(key1); // Output: 'value1'\nconsole.log(rest); // Output: {key2: \"value2\", key3: \"value3\"}\n\n\n\nIn JavaScript, the this keyword refers to the current object that is being executed. It is a special keyword that is used to access properties and methods of the current object.\nThe value of this depends on how the function is called, and it can change depending on the context.\nHere is an example of how this is used in a simple function:\nfunction greet() {\n  console.log(`Hello, ${this.name}!`);\n}\n\nlet person = {\n  name: 'John',\n  greet: greet\n};\n\nperson.greet(); // Output: \"Hello, John!\"\nIn this example, the greet function is called as a method of the person object, so the value of this inside the function is the person object. As a result, the name property of the person object is accessed and logged to the console.\nThe value of this can also be determined by how the function is called. For example:\nlet object = {\n  name: 'John'\n};\n\nfunction greet() {\n  console.log(`Hello, ${this.name}!`);\n}\n\ngreet.call(object); // Output: \"Hello, John!\"\nIn this example, the call() method is used to call the greet function with a specific value for this. The call() method accepts an object as its first argument, which is used as the value of this inside the function.\nThe value of this can also be bound to a specific value using the bind() method:\nlet object = {\n  name: 'John'\n};\n\nfunction greet() {\n  console.log(`Hello, ${this.name}!`);\n}\n\nlet boundGreet = greet.bind(object);\nboundGreet(); // Output: \"Hello, John!\"\nIn this example, the bind() method is used to create a new function, boundGreet, that has its value of this permanently bound to the object.\n\nWe used few keywords like call, apply and bind, lets explore what each of them works\n\n\nCall()\nThe call() method takes a function and an argument list (a comma-separated list of arguments) as its arguments, and calls the function with the specified arguments and the value of this set to the first argument.\nHere is an example of how to use the call() method:\nlet object = {\nname: 'John'\n};\n\nfunction greet(greeting) {\nconsole.log(`${greeting}, ${this.name}!`);\n}\n\ngreet.call(object, 'Hello'); // Output: \"Hello, John!\"\nIn this example, the call() method is used to call the greet function with the object as the value of this and the ‘Hello’ string as the greeting argument.\nApply()\nThe apply() method is similar to the call() method, but it takes a function and an array of arguments as its arguments, rather than a list of arguments.\nHere is an example of how to use the apply() method:\nlet object = {\nname: 'John'\n};\n\nfunction greet(greeting) {\nconsole.log(`${greeting}, ${this.name}!`);\n}\n\ngreet.apply(object, ['Hello']); // Output: \"Hello, John!\"\nBind()\n\nIn JavaScript, the bind() method is a function method that creates a new function with a specific value for this. The new function is called a bound function.\nThe bind() method takes an object as its first argument, which becomes the value of this inside the bound function. It also accepts additional arguments that are passed to the bound function as arguments when it is called.\nHere is an example of how to use the bind() method:\nlet object = {\n  name: 'John'\n};\n\nfunction greet(greeting) {\n  console.log(`${greeting}, ${this.name}!`);\n}\n\nlet boundGreet = greet.bind(object, 'Hello');\nboundGreet(); // Output: \"Hello, John!\"\nIn this example, the bind() method is used to create a new function, boundGreet, that has its value of this permanently bound to the object. The ‘Hello’ string is also passed as an argument to the bind() method, and it becomes the first argument of the bound function when it is called.\nThe bind() method is often used to create functions with a fixed value of this, which can be useful in cases where you need to pass a function as a callback or when you want to bind a method to an object.\nKeep in mind that the bind() method does not call the function immediately. It only creates a new function that can be called later. To call the function immediately, you can use the call() or apply() methods.\nFor example:\nlet object = {\n  name: 'John'\n};\n\nfunction greet(greeting) {\n  console.log(`${greeting}, ${this.name}!`);\n}\n\ngreet.call(object, 'Hello'); // Output: \"Hello, John!\"\n\n\n\nIn JavaScript, the value of this inside an arrow function is determined by the surrounding context. Arrow functions do not have their own this value, so the value of this inside an arrow function is the same as the value of this in the surrounding context.\nHere is an example of an arrow function that uses the this keyword:\nlet object = {\n  name: 'John',\n  greet: () => {\n    console.log(`Hello, ${this.name}!`);\n  }\n};\n\nobject.greet(); // Output: \"Hello, undefined!\"\nIn this example, the greet method is an arrow function that uses the this keyword to access the name property of the surrounding object. However, because arrow functions do not have their own this value, the value of this inside the function is undefined.\nTo fix this, you can use a regular function instead of an arrow function:\nlet object = {\n  name: 'John',\n  greet: function() {\n    console.log(`Hello, ${this.name}!`);\n  }\n};\n\nobject.greet(); // Output: \"Hello, John!\"\nIn this example, the greet method is a regular function that has its own this value, which is determined by the surrounding context. As a result, the name property of the object is accessed correctly.\n\nKeep in mind that arrow functions are often used as a concise syntax for functions, but they have some differences in behavior compared to regular functions, such as the way they handle the this keyword. It is important to understand these differences and use the appropriate type of function for your specific needs.\n\n\n\n\nIn JavaScript, getters and setters are methods that allow you to get and set the value of an object property, respectively. They are a convenient way to define custom behavior for getting and setting the value of a property, and they can be used to create read-only or write-only properties, as well as to validate or transform the value of a property.\nHere is an example of how to use getters and setters:\nlet object = {\n  _property: 'value',\n  get property() {\n    return this._property;\n  },\n  set property(value) {\n    this._property = value;\n  }\n};\n\nconsole.log(object.property); // Output: \"value\"\nobject.property = 'new value';\nconsole.log(object.property); // Output: \"new value\"\nIn this example, the property getter and setter are defined as methods with the get and set keywords, respectively. The getter is used to get the value of the _property property, and the setter is used to set the value of the _property property.\nTo use a getter or setter, you can use the property name as if it were a normal property, without calling the method. For example, object.property is used to get the value of the property getter, and object.property = value is used to set the value of the property setter.\nGetters and setters can be used to create read-only or write-only properties by omitting the getter or setter, respectively. For example:\nlet object = {\n  _property: 'value',\n  get property() {\n    return this._property;\n  }\n};\n\nconsole.log(object.property); // Output: \"value\"\nobject.property = 'new value';\nconsole.log(object.property); // Output: \"value\"\nIn this example, the property getter is defined, but the property setter is omitted, which makes the property a read-only property."
  },
  {
    "objectID": "timer.html",
    "href": "timer.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "The setInterval() function is used to execute a function or block of code repeatedly, at a specified interval.\nHere is an example to simulate a student’s increasing knowledge every day\nlet knowledge = 0;\n\nfunction increaseKnowledge() {\n  knowledge++;\n  console.log(`Student's knowledge has increased to ${knowledge}.`);\n}\n\nsetInterval(increaseKnowledge, 86400000); // Execute every 24 hours (86400000 milliseconds)\nIn this example, the increaseKnowledge() function is passed to setInterval() as a callback function, and is executed every 24 hours (86400000 milliseconds). The knowledge variable is incremented on each iteration, and a message is logged to the console indicating the student’s increased knowledge.\n\n\n\nYou can use clearInterval() to stop the timer and stop the student’s knowledge from increasing. For example:\nlet timerId = setInterval(increaseKnowledge, 86400000);\n\n// Stop the timer after a certain amount of time\nsetTimeout(function() {\n  clearInterval(timerId);\n  console.log('Timer stopped.');\n}, 1000000);\nIn this example, the timer is stopped after 1 million milliseconds (about 11.6 days). You can adjust the delay and interval values to suit your needs.\n\n\n\nThe setTimeout() function is used to execute a function or block of code after a specified delay\n\nlet count = 0;\n\nfunction incrementCounter() {\n  count++;\n  console.log(count);\n  setTimeout(incrementCounter, 1000);\n}\n\nsetTimeout(incrementCounter, 1000);\n// Output: 1 (after a 1 second delay)\n//         2 (after a 1 second delay)\n//         3 (after a 1 second delay)\n//         ...\n\nIn this example, the incrementCounter() function is passed to setTimeout() as a callback function, and is executed every 1 second. The count variable is incremented and logged to the console on each iteration.\n\n\n\nThe requestAnimationFrame() function is used to schedule a function or block of code to be executed before the browser’s next repaint. It allows you to animate elements on a web page by repeatedly executing a function or block of code, while ensuring that the animation runs smoothly and efficiently.\nHere is an example of using requestAnimationFrame() to animate a div element:\nconst div = document.getElementById('animated-div');\nlet x = 0;\n\nfunction animate() {\n  div.style.left = x + 'px';\n  x++;\n  requestAnimationFrame(animate);\n}\n\nrequestAnimationFrame(animate);\nIn this example, the animate() function is passed to requestAnimationFrame() as a callback function, and is executed before each repaint. It updates the left style property of the div element, causing it to move horizontally across the screen.\nThe requestAnimationFrame() function returns an ID that can be used to cancel the animation using the cancelAnimationFrame() function. For example:\nlet animationId = requestAnimationFrame(animate);\n\n// Stop the animation after a certain amount of time\nsetTimeout(function() {\n  cancelAnimationFrame(animationId);\n  console.log('Animation stopped.');\n}, 1000);\nIn this example, the animation is stopped after 1 second (1000 milliseconds). You can adjust the delay value to suit your needs.\nThe requestAnimationFrame() function is more efficient than using setTimeout() or setInterval() for animating elements, because it allows the browser to optimize the rendering of the animation and to synchronize it with the refresh rate of the display. This can result in smoother, more fluid animations and can help to improve the performance of your web applications."
  },
  {
    "objectID": "modern.html",
    "href": "modern.html",
    "title": "ModernJs",
    "section": "",
    "text": "A more concise function syntax, particularly useful for replacing short anonymous functions. The basic syntax for an arrow function is:\n(param1, param2) => {\n    clapHand(param1, param2);\n    return 'This worked';\n}\nHowever, if an arrow function only requires one line, then the curly braces and return keywords can be removed. Additionally, when these are used inline such as for a call to the array map function, the semicolon must be removed. Finally, if there is only one parameter, the parantheses around the parameter can also be removed. For example, this code will create and array with the values doubled:\n[1,2,3,4].map(num => num * 2);\nThere are few constratins to arrow functions which will be explored througouht the course. The most important of these is that arrow fucntions do not have their own  this  binding. Additionally,arrow functions cannot be used as a constructors or generators."
  },
  {
    "objectID": "modern.html#destructuring-assignment",
    "href": "modern.html#destructuring-assignment",
    "title": "ModernJs",
    "section": "Destructuring Assignment",
    "text": "Destructuring Assignment\n\nArray Destructuring\n\nconst [fist, second] = [1,2,3];\nconsole.log(first) // 1\nconsole.log(second) // 2\n\nWhen destructuring object it can also be renamed\n\nconst car = {\n    color: white,\n    model: Dodge,\n    vin: 123123123123,\n    engine: []\n}\n\nconst {color: dodgeColor, model: isDodge} = car\n\nconsole.log(dodgeColor) // white\nconsole.log(isDodge) // model\n\nDestructuring can also be used in a function parameter, for example\n\nfunction displayName({name}) {\n    console.log(name)\n}"
  },
  {
    "objectID": "modern.html#rest-operator",
    "href": "modern.html#rest-operator",
    "title": "ModernJs",
    "section": "Rest Operator",
    "text": "Rest Operator\nA javascript operator using … for condensing multiple elements into a single array. This uses the same synatx as the spread operator, but funtionality is essentially the opposite.\nRest syntax can be used in both arrays and objects to get all of the values not being destructured. For example:\n\nconst floffy = [\"Hey\", \"Floppy\", \"is\", \"my\", \"best friend\", \".\"]\nconst [firstWord, secondWord, ...rem] = floffy // ..rem is [\"is\", \"my\", \"best friend\", \".\"]\n\n// Rest on Object\n\nconst {key1, key2, ...rem} = car //  ...rem is {vin: value, engine:[]}"
  },
  {
    "objectID": "modern.html#spread-operator",
    "href": "modern.html#spread-operator",
    "title": "ModernJs",
    "section": "Spread Operator",
    "text": "Spread Operator\nIn JavaScript, the spread operator (…) is a syntax that allows you to expand an iterable object (such as an array or a string) into a list of its individual elements. It is often used in combination with other features such as destructuring and the rest/spread operator (…).\nHere is an example of how to use the spread operator:\nlet array1 = [1, 2, 3];\nlet array2 = [...array1, 4, 5];\n\nconsole.log(array2); // Output: [1, 2, 3, 4, 5]\nIn this example, the spread operator is used to expand the elements of the array1 into a list, which is then combined with the 4 and 5 elements to create a new array, array2.\nThe spread operator can also be used to spread the elements of an array into the arguments of a function, like this:\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nlet array = [1, 2, 3];\n\nconsole.log(sum(...array)); // Output: 6\nIn this example, the spread operator is used to spread the elements of the array into the arguments of the sum function, which adds them together and returns the result."
  },
  {
    "objectID": "modern.html#template-literal",
    "href": "modern.html#template-literal",
    "title": "ModernJs",
    "section": "Template Literal",
    "text": "Template Literal\nIn JavaScript, a template literal is a way to define a string that spans multiple lines and can contain expressions. Template literals are surrounded by backticks (`), rather than single or double quotes.\nHere is an example of a template literal that spans multiple lines and includes an expression:\nconst name = 'Bob';\nconst age = 30;\n\nconst message = `Hello, my name is ${name} and I am ${age} years old.`;\n// Output: \"Hello, my name is Bob and I am 30 years old.\"\nIn this example, the name and age variables are interpolated into the string using the ${} syntax. This is known as string interpolation.\nTemplate literals also allow you to define strings that span multiple lines, which can be useful for creating longer, more readable strings.\nconst html = `\n<div>\n  <h1>Hello, World!</h1>\n  <p>This is a paragraph</p>\n</div>\n`;\nTemplate literals were introduced in JavaScript as part of the ES6 (ECMAScript 6) specification. They provide a more powerful and flexible way to define strings compared to traditional string literals."
  },
  {
    "objectID": "modern.html#null-coalescing",
    "href": "modern.html#null-coalescing",
    "title": "ModernJs",
    "section": "Null Coalescing",
    "text": "Null Coalescing\nIn JavaScript, the null coalescing operator (??) is a logical operator that returns the first operand if it exists and is not null, or the second operand if the first operand is either null or undefined. It is a shorthand way of writing a conditional expression that checks for null or undefined.\nHere is an example of using the null coalescing operator:\nconst user = { name: 'Bob' };\n\nconst username = user.name ?? 'Guest';\n// Output: \"Bob\"\nIn this example, the username variable is assigned the value of user.name if it exists and is not null, or the string ‘Guest’ if user.name is either null or undefined.\nHere is the same example written using a conditional expression:\nconst username = user.name !== null && user.name !== undefined ? user.name : 'Guest';\nThe null coalescing operator can be useful when you want to provide a default value for a variable that might be null or undefined. It can also be used to simplify code by reducing the need for nested conditional expressions.\nThe null coalescing operator was introduced in JavaScript as part of the ES2020 (ECMAScript 2020) specification. It is supported in modern browsers and can be used with transpilers like Babel to support older browsers."
  },
  {
    "objectID": "modern.html#optional-chaining",
    "href": "modern.html#optional-chaining",
    "title": "ModernJs",
    "section": "Optional Chaining",
    "text": "Optional Chaining\nIn JavaScript, optional chaining is a feature that allows you to access an object’s properties, methods, or elements without having to check for null or undefined values. It is a shorthand way of writing a series of checks to see if an object, property, or element exists before trying to access it.\nHere is an example of using optional chaining to access an object’s property:\nconst user = { name: 'Bob' };\n\nconst username = user?.name;\n// Output: \"Bob\"\nIn this example, the username variable is assigned the value of user.name if user exists and is not null or undefined. If user is null or undefined, the value of username will be undefined.\nHere is the same example written without optional chaining:\nlet username;\nif (user && user.name) {\n  username = user.name;\n}\nOptional chaining can be useful when you want to access properties or elements of an object that may not exist, or when you are working with data that may be null or undefined. It can also help to simplify code by reducing the need for nested conditional statements.\nOptional chaining was introduced in JavaScript as part of the ES2020 (ECMAScript 2020) specification. It is supported in modern browsers and can be used with transpilers like Babel to support older browsers."
  },
  {
    "objectID": "modern.html#short-circuit-evaulation",
    "href": "modern.html#short-circuit-evaulation",
    "title": "ModernJs",
    "section": "Short Circuit Evaulation",
    "text": "Short Circuit Evaulation\nIn JavaScript, short-circuit evaluation is a feature that allows you to use logical operators (such as && and ||) to evaluate expressions and determine the value of a boolean expression. It is called “short-circuit” evaluation because the second operand is only evaluated if the first operand is not sufficient to determine the value of the expression.\nHere is an example of short-circuit evaluation using the && operator:\nconst user = { name: 'Bob' };\n\nconst username = user && user.name;\n// Output: \"Bob\"\nIn this example, the username variable is assigned the value of user.name if user exists and is not null or undefined. If user is null or undefined, the value of username will be undefined. This is because the && operator only evaluates the second operand (user.name) if the first operand (user) is truthy.\nHere is the same example written without short-circuit evaluation:\nlet username;\nif (user) {\n  username = user.name;\n}\nShort-circuit evaluation can be useful for reducing the number of conditional statements in your code, and for simplifying complex boolean expressions.\n\nNote that short-circuit evaluation is only possible with the && and || operators. It is not possible with the & and | operators, which always evaluate both operands regardless of the value of the first operand.\n\n|| operator only needs one expression to be true, if the left side is true then the right side will not be evaluated. This is quite the opposite of the && operator. For example,\ntrue || myFunc() // doesn't call myFunc\nfalse || myFunc() // calls myFunc"
  },
  {
    "objectID": "browserStorage.html",
    "href": "browserStorage.html",
    "title": "JavaScript Crash Course",
    "section": "",
    "text": "Browser storage refers to the various mechanisms that are available for storing data in a web browser, such as cookies, local storage, and session storage. These mechanisms allow you to store data on the client-side, so that it can be accessed and modified by your web application, even after the page has been refreshed or the browser has been closed and reopened.\nCookies are small pieces of data that are stored on the client-side and sent back to the server with every request. They are typically used to store session-specific data, such as authentication tokens or user preferences. Cookies are limited in size and are stored in plain text, which makes them less suitable for storing large amounts of data or sensitive information.\nLocal storage and session storage are similar to cookies, but offer more storage space and additional features, such as the ability to store complex data types and to access data across multiple windows and tabs. Local storage stores data permanently, even after the browser has been closed and reopened, while session storage stores data for a single session, and is deleted when the browser is closed.\nHere is an example of using local storage to store and retrieve data:\nlocalStorage.setItem('userName', 'John');\nconst userName = localStorage.getItem('userName');\nconsole.log(userName); // Output: \"John\"\nIn this example, the setItem() method is used to store a value in local storage, and the getItem() method is used to retrieve the value. The data stored in local storage is available even after the page has been refreshed or the browser has been closed and reopened.\nBrowser storage can be a useful tool for storing data on the client-side and for maintaining state across multiple sessions. It can help you to build more responsive and interactive web applications, and to create a more seamless user experience.\n\n\nSession storage is a client-side storage mechanism that is similar to local storage, but stores data for a single session only. In other words, data stored in session storage is deleted when the user closes the browser or ends the browsing session.\nSession storage is useful for storing data that is specific to a single session, such as authentication tokens or temporary data that is not needed after the session has ended. It can be accessed and modified using the sessionStorage object, which provides methods for storing and retrieving data, such as setItem(), getItem(), and removeItem().\nHere is an example of using session storage to store and retrieve data:\nsessionStorage.setItem('userName', 'John');\nconst userName = sessionStorage.getItem('userName');\nconsole.log(userName); // Output: \"John\"\nIn this example, the setItem() method is used to store a value in session storage, and the getItem() method is used to retrieve the value. The data stored in session storage is available only during the current session, and is deleted when the user closes the browser or ends the browsing session.\nSession storage can be a useful tool for storing data on the client-side and for maintaining state across multiple pages or requests within a single session. It can help you to build more responsive and interactive web applications, and to create a more seamless user experience.\n\n\n\nLocal storage is a client-side storage mechanism that allows you to store data on the client-side, so that it can be accessed and modified by your web application, even after the page has been refreshed or the browser has been closed and reopened.\nLocal storage is useful for storing data that needs to be persistent, such as user preferences or settings, or data that needs to be available across multiple sessions, such as authentication tokens. It can be accessed and modified using the localStorage object, which provides methods for storing and retrieving data, such as setItem(), getItem(), and removeItem().\nHere is an example of using local storage to store and retrieve data:\nlocalStorage.setItem('userName', 'John');\nconst userName = localStorage.getItem('userName');\nconsole.log(userName); // Output: \"John\"\nIn this example, the setItem() method is used to store a value in local storage, and the getItem() method is used to retrieve the value. The data stored in local storage is available even after the page has been refreshed or the browser has been closed and reopened."
  },
  {
    "objectID": "behavioral.html",
    "href": "behavioral.html",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "Algorithm abstraction refers to the practice of breaking down a complex algorithm into smaller, more manageable parts that can be easily reused and recombined to create new solutions. This process of simplification allows developers to focus on specific components of the algorithm, making it easier to understand, modify and maintain. Additionally, it makes it possible to use the individual components to create new variations or solutions to different problems, making the development process more efficient and flexible."
  },
  {
    "objectID": "behavioral.html#strategy-pattern-in-simple-terms",
    "href": "behavioral.html#strategy-pattern-in-simple-terms",
    "title": "Behavioral Design Pattern",
    "section": "Strategy Pattern in Simple Terms",
    "text": "Strategy Pattern in Simple Terms\nA strategy design pattern is like having a toolbox with different tools for different jobs. Imagine you need to build a house, and you have a hammer, a screwdriver, a saw, and a drill. Each tool is good for a specific job, like the hammer is good for hitting nails, the screwdriver is good for turning screws, the saw is good for cutting wood, and the drill is good for making holes.\nSo, if you need to build a house, you might use the hammer to put nails in the wood, the saw to cut the wood to the right size, the screwdriver to put the screws in and the drill to make holes for the pipes.\nThis is similar to how a computer program can use different ways of doing things depending on what it needs to do. Just like how you choose the right tool for the job, the program can choose the right strategy for the task."
  },
  {
    "objectID": "behavioral.html#components-of-the-strategy-pattern",
    "href": "behavioral.html#components-of-the-strategy-pattern",
    "title": "Behavioral Design Pattern",
    "section": "Components of the Strategy Pattern",
    "text": "Components of the Strategy Pattern\nThe strategy pattern consists of several components that work together to allow an algorithm’s behavior to be selected and changed dynamically:\n\nThe strategy interface defines a common interface for all the strategy objects. This interface defines the methods that the strategy objects must implement.\nThe concrete strategy classes implement the strategy interface and define specific algorithms or behaviors. These classes are interchangeable and can be selected and changed at runtime.\nThe context class holds a reference to a strategy object and defines a common interface for the client code to interact with the strategy objects. The context class delegates the task to the strategy object it holds.\nThe client code is the code that uses the context class and the strategy objects. The client code can work with any strategy object through the common interface defined by the context class, without needing to know the details of the concrete strategy classes.\nThe strategy factory creates the strategy objects and assigns them to the context class. This factory can create multiple strategy objects and allows the client code to switch between them.\n\nOverall, the strategy pattern allows for the separation of concerns, making the code more flexible, maintainable, and reusable."
  },
  {
    "objectID": "behavioral.html#example",
    "href": "behavioral.html#example",
    "title": "Behavioral Design Pattern",
    "section": "Example",
    "text": "Example\n// Define the strategy interface\nclass Strategy {\n    execute() {\n        throw new Error(\"This method must be implemented\");\n    }\n}\n\n// Define concrete strategy classes\nclass ConcreteStrategyA extends Strategy {\n    execute() {\n        console.log(\"Executing strategy A\");\n    }\n}\n\nclass ConcreteStrategyB extends Strategy {\n    execute() {\n        console.log(\"Executing strategy B\");\n    }\n}\n\nclass ConcreteStrategyC extends Strategy {\n    execute() {\n        console.log(\"Executing strategy C\");\n    }\n}\n\n// Define the context class\nclass Context {\n    constructor(strategy) {\n        this.strategy = strategy;\n    }\n\n    setStrategy(strategy) {\n        this.strategy = strategy;\n    }\n\n    executeStrategy() {\n        this.strategy.execute();\n    }\n}\n\n// Client code\nconst context = new Context(new ConcreteStrategyA());\ncontext.executeStrategy(); // Output: \"Executing strategy A\"\n\ncontext.setStrategy(new ConcreteStrategyB());\ncontext.executeStrategy(); // Output: \"Executing strategy B\"\n\ncontext.setStrategy(new ConcreteStrategyC());\ncontext.executeStrategy(); // Output: \"Executing strategy C\""
  },
  {
    "objectID": "behavioral.html#a-real-world-example-of-the-strategy-pattern",
    "href": "behavioral.html#a-real-world-example-of-the-strategy-pattern",
    "title": "Behavioral Design Pattern",
    "section": "A Real-World Example of the Strategy Pattern",
    "text": "A Real-World Example of the Strategy Pattern\nA real-world example of the strategy pattern might be an e-commerce website that allows customers to choose different shipping options at checkout. The website might have several shipping options, such as standard shipping, express shipping, and overnight shipping. Each shipping option has different costs, delivery times, and requirements.\n// Define the strategy interface\nclass ShippingStrategy {\n    calculateCost() {\n        throw new Error(\"This method must be implemented\");\n    }\n\n    deliveryTime() {\n        throw new Error(\"This method must be implemented\");\n    }\n\n    getDescription() {\n        throw new Error(\"This method must be implemented\");\n    }\n}\n\n// Define concrete strategy classes\nclass StandardShipping extends ShippingStrategy {\n    calculateCost() {\n        return 5;\n    }\n\n    deliveryTime() {\n        return \"5-7 business days\";\n    }\n\n    getDescription() {\n        return \"Standard Shipping\";\n    }\n}\n\nclass ExpressShipping extends ShippingStrategy {\n    calculateCost() {\n        return 10;\n    }\n\n    deliveryTime() {\n        return \"2-3 business days\";\n    }\n\n    getDescription() {\n        return \"Express Shipping\";\n    }\n}\n\nclass OvernightShipping extends ShippingStrategy {\n    calculateCost() {\n        return 20;\n    }\n\n    deliveryTime() {\n        return \"Next business day\";\n    }\n\n    getDescription() {\n        return \"Overnight Shipping\";\n    }\n}\n\n// Define the context class\nclass Order {\n    constructor(shippingStrategy) {\n        this.shippingStrategy = shippingStrategy;\n        this.items = [];\n    }\n\n    setShippingStrategy(shippingStrategy) {\n        this.shippingStrategy = shippingStrategy;\n    }\n\n    addItem(item) {\n        this.items.push(item);\n    }\n\n    calculateTotalCost() {\n        let cost = 0;\n        for (let item of this.items) {\n            cost += item.price;\n        }\n        return cost + this.shippingStrategy.calculateCost();\n    }\n\n    getShippingDescription() {\n        return this.shippingStrategy.getDescription();\n    }\n\n    getDeliveryTime() {\n        return this.shippingStrategy.deliveryTime();\n    }\n}\n\n// Client code\nconst order = new Order(new StandardShipping());\nconsole.log(\"Shipping Description: \", order.getShippingDescription());\nconsole.log(\"Delivery Time: \", order.getDeliveryTime());\nconsole.log(\"Total Cost: \", order.calculateTotalCost());\n\norder.setShippingStrategy(new ExpressShipping());\nconsole.log(\"Shipping Description: \", order.getShippingDescription());\nconsole.log(\"Delivery Time: \", order.getDeliveryTime());\nconsole.log(\"Total Cost: \", order.calculateTotalCost());\n\norder.setShippingStrategy(new OvernightShipping());\nconsole.log(\"Shipping Description: \", order.getShippingDescription());\nconsole.log(\"Delivery Time: \", order.getDeliveryTime());\nconsole.log(\"Total Cost: \", order.calculateTotalCost());"
  },
  {
    "objectID": "behavioral.html#another-example-of-the-strategy-pattern",
    "href": "behavioral.html#another-example-of-the-strategy-pattern",
    "title": "Behavioral Design Pattern",
    "section": "Another Example of the Strategy Pattern",
    "text": "Another Example of the Strategy Pattern\n\nlet OutputFormat = Object.freeze({\n  markdown: 0,\n  html: 1\n});\n\nclass ListStrategy\n{\n  start(buffer) {}\n  end(buffer) {}\n  addListItem(buffer, item) {}\n}\n\nclass MarkdownListStrategy extends ListStrategy\n{\n  addListItem(buffer, item) {\n    buffer.push(` * ${item}`);\n  }\n}\n\nclass HtmlListStrategy extends ListStrategy\n{\n  start(buffer) {\n    buffer.push('<ul>');\n  }\n\n  end(buffer)\n  {\n    buffer.push('</ul>');\n  }\n\n  addListItem(buffer, item) {\n    buffer.push(`  <li>${item}</li>`)\n  }\n}\n\nclass TextProcessor\n{\n  constructor(outputFormat)\n  {\n    this.buffer = [];\n    this.setOutputFormat(outputFormat);\n  }\n\n  setOutputFormat(format)\n  {\n    switch (format)\n    {\n      case OutputFormat.markdown:\n        this.listStrategy = new MarkdownListStrategy();\n        break;\n      case OutputFormat.html:\n        this.listStrategy = new HtmlListStrategy();\n        break;\n    }\n  }\n\n  appendList(items)\n  {\n    this.listStrategy.start(this.buffer);\n    for (let item of items)\n      this.listStrategy.addListItem(this.buffer, item);\n    this.listStrategy.end(this.buffer);\n  }\n\n  clear()\n  {\n    this.buffer = [];\n  }\n\n  toString()\n  {\n    return this.buffer.join('\\n');\n  }\n}\n\nlet tp = new TextProcessor();\ntp.setOutputFormat(OutputFormat.markdown);\ntp.appendList(['foo', 'bar', 'baz']);\nconsole.log(tp.toString());\n\ntp.clear();\ntp.setOutputFormat(OutputFormat.html);\ntp.appendList(['alpha', 'beta', 'gamma']);\nconsole.log(tp.toString());"
  },
  {
    "objectID": "behavioral.html#appropriate-scenario-to-use-the-strategy-pattern",
    "href": "behavioral.html#appropriate-scenario-to-use-the-strategy-pattern",
    "title": "Behavioral Design Pattern",
    "section": "Appropriate Scenario to Use the Strategy Pattern",
    "text": "Appropriate Scenario to Use the Strategy Pattern\nThe strategy pattern should be used when you have a set of related algorithms or behaviors that are interchangeable, and you want to be able to select and change the behavior at runtime. Some common scenarios where the strategy pattern is useful include:\n\nYou have a class that needs to perform one of several related algorithms, and you want to encapsulate the algorithms as objects to make the class more flexible and maintainable.\nYou want to be able to add new algorithms or behaviors to a system without modifying the existing code.\nYou want to be able to switch between different algorithms or behaviors at runtime, depending on the situation or context.\nYou want to encapsulate a class that uses a large number of conditional statements and make it more readable and maintainable\nYou have a algorithm that has multiple variations and you want to encapsulate each variation and make it interchangeable with other variations.\n\nIn general, the strategy pattern is a powerful tool for creating flexible, reusable, and maintainable code, and it can help to simplify complex systems by breaking them down into smaller, more manageable parts."
  },
  {
    "objectID": "behavioral.html#template-method-in-simple-term",
    "href": "behavioral.html#template-method-in-simple-term",
    "title": "Behavioral Design Pattern",
    "section": "Template Method in Simple Term",
    "text": "Template Method in Simple Term\nThe template method pattern is like a recipe for making something. Imagine you want to make a cake, and you have a recipe that tells you the steps to make it. The recipe is like a template, it tells you the order of the steps, but not all the details of how to do each step.\nFor example, the recipe might say “Mix the ingredients together”, but it doesn’t tell you exactly how to mix them. You can use a spoon or a mixer, or you can mix them by hand. The recipe just tells you the general way to do it, but you can choose the specific details.\nThis is similar to how computer programs can use a template method to do a series of steps in a specific order, but some of the steps might be different depending on the situation. Just like how you can choose the specific details of how to mix the ingredients in a recipe, the program can choose the specific details of how to do each step."
  },
  {
    "objectID": "behavioral.html#template-method-example",
    "href": "behavioral.html#template-method-example",
    "title": "Behavioral Design Pattern",
    "section": "Template Method Example",
    "text": "Template Method Example\n\nclass AbstractClass {\n    templateMethod() {\n        this.step1();\n        this.step2();\n        this.step3();\n    }\n\n    step1() {\n        console.log(\"step1 (AbstractClass)\");\n    }\n\n    step2() {\n        console.log(\"step2 (AbstractClass)\");\n    }\n\n    step3() {\n        console.log(\"step3 (AbstractClass)\");\n    }\n}\n\nclass ConcreteClass extends AbstractClass {\n    step2() {\n        console.log(\"step2 (ConcreteClass)\");\n    }\n}\n\n// Client code\nconst concreteClass = new ConcreteClass();\nconcreteClass.templateMethod();\n/* Output:\nstep1 (AbstractClass)\nstep2 (ConcreteClass)\nstep3 (AbstractClass)\n*/"
  },
  {
    "objectID": "behavioral.html#real-world-example-of-the-template-method-pattern",
    "href": "behavioral.html#real-world-example-of-the-template-method-pattern",
    "title": "Behavioral Design Pattern",
    "section": "Real World Example of the Template Method Pattern",
    "text": "Real World Example of the Template Method Pattern\nA real-world example of the template method pattern in JavaScript might be a web application that allows users to create custom reports. The application might have a base class that defines a template method for creating a report, which includes several common steps such as querying the database, formatting the data, and generating the final report.\nclass ReportTemplate {\n    generateReport(reportData) {\n        this.fetchData(reportData);\n        this.formatData();\n        this.generateOutput();\n    }\n\n    fetchData(reportData) {\n        console.log(\"Fetching data from database (ReportTemplate)\");\n    }\n\n    formatData() {\n        console.log(\"Formatting data (ReportTemplate)\");\n    }\n\n    generateOutput() {\n        console.log(\"Generating final report (ReportTemplate)\");\n    }\n}\n\nclass SalesReport extends ReportTemplate {\n    fetchData(reportData) {\n        console.log(\"Fetching sales data from database (SalesReport)\");\n    }\n}\n\nclass InventoryReport extends ReportTemplate {\n    fetchData(reportData) {\n        console.log(\"Fetching inventory data from database (InventoryReport)\");\n    }\n}\n\n// Client code\nconst salesReport = new SalesReport();\nsalesReport.generateReport();\n// Output:\n// Fetching sales data from database (SalesReport)\n// Formatting data (ReportTemplate)\n// Generating final report (ReportTemplate)\n\nconst inventoryReport = new InventoryReport();\ninventoryReport.generateReport();\n// Output:\n// Fetching inventory data from database (InventoryReport)\n// Formatting data (ReportTemplate)\n// Generating final report (ReportTemplate)\nAnother common scenario where the template method pattern is used is in building a financial application. For example, an application that manages investment portfolios. The application might have a base class that defines a template method for calculating the return on investment (ROI) of a portfolio, which includes several common steps such as fetching the portfolio data, calculating the returns and generating the final report.\nclass ROICalculator {\n    calculateROI(portfolio) {\n        this.fetchData(portfolio);\n        this.calculateReturns();\n        this.generateReport();\n    }\n\n    fetchData(portfolio) {\n        // Fetch data from the portfolio\n    }\n\n    calculateReturns() {\n        // Calculate returns on the portfolio\n    }\n\n    generateReport() {\n        // Generate final report\n    }\n}\n\nclass StockPortfolio extends ROICalculator {\n    fetchData(portfolio) {\n        // Fetch stock data for the portfolio\n    }\n}\n\nclass RealEstatePortfolio extends ROICalculator {\n    fetchData(portfolio) {\n        // Fetch real estate data for the portfolio\n    }\n}\nLast Example:\nclass Game {\n  constructor(numberOfPlayers)\n  {\n    this.numberOfPlayers = numberOfPlayers;\n    this.currentPlayer = 0;\n  }\n\n  run() {\n    this.start();\n    while (!this.haveWinner) {\n      this.takeTurn();\n    }\n    console.log(`Player ${this.winningPlayer} wins.`);\n  }\n\n  start(){}\n  get haveWinner(){}\n  takeTurn(){}\n  get winningPlayer(){}\n}\n\nclass Chess extends Game\n{\n  constructor()\n  {\n    super(2);\n    this.maxTurns = 10;\n    this.turn = 1;\n  }\n\n  start()\n  {\n    console.log(\n      `Starting a game of chess with ${this.numberOfPlayers} players.`\n    );\n  }\n\n  get haveWinner()\n  {\n    return this.turn === this.maxTurns;\n  }\n\n  takeTurn() {\n    console.log(\n      `Turn ${this.turn++} taken by player ${this.currentPlayer}.`\n    );\n    this.currentPlayer = (this.currentPlayer + 1) % this.numberOfPlayers;\n  }\n\n  get winningPlayer()\n  {\n    return this.currentPlayer;\n  }\n}\n\nlet chess = new Chess();\nchess.run();"
  },
  {
    "objectID": "behavioral.html#applicability",
    "href": "behavioral.html#applicability",
    "title": "Behavioral Design Pattern",
    "section": "Applicability",
    "text": "Applicability\nThe template method pattern is an appropriate solution when you have an algorithm with a fixed structure that needs to be executed in a specific order, but one or more of the steps might vary depending on the situation or context. Some common scenarios where the template method pattern is used include:\n\nYou have a process that needs to be executed in a specific order, but some of the steps might vary depending on the situation or context. For example, a financial application that calculates the return on investment (ROI) of a portfolio may need to fetch data, calculate returns and generate a report, but the data fetching process may vary depending on the type of portfolio.\nYou want to allow subclasses to provide specific implementations for one or more of the steps of the algorithm, while still ensuring that the overall structure of the algorithm remains the same.\nYou want to encapsulate a complex algorithm in a single method and make it reusable across different classes and situations.\nYou have a framework that needs to be customized for different use cases, but the overall structure of the framework should remain the same.\nYou want to be able to add new functionality to a system without modifying existing code.\n\nIn general, the template method pattern is a powerful tool for creating flexible, reusable, and maintainable code, and it can help to simplify complex systems by breaking them down into smaller, more manageable parts."
  }
]